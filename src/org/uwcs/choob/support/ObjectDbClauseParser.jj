options {
	IGNORE_CASE = true;
	STATIC = false;
}

PARSER_BEGIN(ObjectDbClauseParser)
	package org.uwcs.choob.support;
	import java.util.Map;
	import java.util.List;
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.Iterator;
	import java.io.StringReader;

	public class ObjectDbClauseParser {
		private Map nameMap = new HashMap();
		private int joins = 0;
		private List joinList = new ArrayList();
		private String sortOrder = "";
		private String limitTo = "";

		public static void main(String args[])
		{
			try
			{
				for(int i=0; i<args.length; i++)
					System.out.println(getSQL(args[i], null));
			}
			catch (ParseException e)
			{
				System.out.println("Parse exception: " + e);
				e.printStackTrace();
			}
		}

		public static String getSQL(String clause, String className) throws ParseException {
			ObjectDbClauseParser parser = new ObjectDbClauseParser (new StringReader(clause));

			String whereClause = parser.ClauseList();
			StringBuffer joinText = new StringBuffer();
			Iterator l = parser.joinList.listIterator();
			int i = 0;
			while( l.hasNext() )
			{
				String fieldName = (String)l.next();
				joinText.append("INNER JOIN ObjectStoreData o" + i + " ON ObjectStore.ObjectID = o" + i + ".ObjectID AND o" + i + ".FieldName = \"" + fieldName + "\" ");
				i++;
			}
			String classQuery = (className == null) ? "" : " AND ClassName = \"" + className + "\" ";
			return joinText.toString() + "WHERE " + whereClause + classQuery + parser.sortOrder + parser.limitTo;
		}

		public String getFieldName(String name)
		{
			String realName = (String)nameMap.get(name.toLowerCase());
			if (realName != null)
				return realName;
			// Need to add!
			realName = "o"+joins+".FieldValue";
			joinList.add(name.toLowerCase());
			joins++;
			nameMap.put(name.toLowerCase(), realName);
			return realName;
		}
	}
PARSER_END(ObjectDbClauseParser)

<*>
SKIP: { " " | "\n" | "\t" }

// Definitions
TOKEN: {
	<#NUMVALUE: ( ["0"-"9"] ) + ( "." ( ["0"-"9"] ) + )?>
|	<#GENVALUE: <NUMVALUE> | <TEXTVALUE>>
|	<#TEXTVALUE: "\"" ( ~ ["\"", "\\"] | "\\" ~[] ) * "\"" | "'" ( ~ ["'", "\\"] | "\\" ~[] ) * "'">
|	<#NAME: ["a"-"z"] ( ["a"-"z", "0"-"9", "_"] )* >
}

TOKEN: {
	<_OPENBRACKET: "("> : DEFAULT
|	<NOT: "!" | "NOT"> : DEFAULT
|	<SORT: "SORT" ( " BY" )?> : S_SORT
|	<LIMIT: "LIMIT"> : S_LIMIT
|	<_NAME: <NAME>> : S_OP
}

<S_SORT>
TOKEN: {
	<ASC: "ASC"> : S_SORT
|	<DESC: "DESC"> : S_SORT
|	<SORT_NAME: <NAME>> : S_NEXT
}

<S_LIMIT>
TOKEN: {
	<LIMIT_OPENBRACKET: "("> : S_LIMIT2
}

<S_LIMIT2>
TOKEN: {
	<LIMIT_NUMVALUE: <NUMVALUE>> : S_LIMIT3
}

<S_LIMIT3>
TOKEN: {
	<LIMIT_COMMA: ","> : S_LIMIT2
|	<LIMIT_CLOSEBRACKET: ")"> : S_NEXT
}

<S_NUMVALUE>
TOKEN: {
	<_NUMVALUE: <NUMVALUE>> : S_NEXT
}

<S_GENVALUE>
TOKEN: {
	<_GENVALUE: <GENVALUE>> : S_NEXT
}

<S_TEXTVALUE>
TOKEN: {
	<_TEXTVALUE: <TEXTVALUE>> : S_NEXT
}

<S_OP>
TOKEN: {
	<NUMOP: "<" | ">"> : S_NUMVALUE
|	<GENOP: "=" | "!="> : S_GENVALUE
|	<RLIKE: "RLIKE" | "REGEXP" | "~"> : S_TEXTVALUE
|	<LIKE: "LIKE"> : S_TEXTVALUE
}

<S_NEXT>
TOKEN: {
	<_CLOSEBRACKET: ")"> : S_NEXT
|	<AND: "AND" | "&&"> : DEFAULT
|	<OR: "OR" | "||"> : DEFAULT
}

/*
	ClauseList() = Clause() ClauseExtra()
*/
String ClauseExtra () :
	{
		String s;
		StringBuffer t = new StringBuffer();
	}
	{
		(
			<AND> s = Clause()
			{
				 t.append(" AND " + s);
			}
		|
			<OR> s = Clause()
			{
				t.append(" OR " + s);
			}
		)*
		{
			return t.toString();
		}
	}

String ClauseList () :
	{
		String s, t;
	}
	{
		s = Clause() t = ClauseExtra()
		{
			return s + t;
		}
	}

String Clause() :
	{
		java.util.Vector list;
		String s;
		Token t;
		int i;
	}
	{
		<NOT> s = Clause()
		{
			return "NOT " + s;
		}
	|
		t = <_NAME> s = OperatorAndValue(t.image)
		{
			return s;
		}
	|
		<_OPENBRACKET> s = ClauseList() <_CLOSEBRACKET>
		{
			return "(" + s + ")";
		}
	|
		<SORT> ParseSort()
		{ return "1"; }
	|
		<LIMIT> ParseLimit()
		{ return "1"; }
	}

String OperatorAndValue(String name) :
	{
		String realName = getFieldName(name);
		Token s, t;
	}
	{
		s = <NUMOP> t = <_NUMVALUE>
		{
			return realName + " " + s.image + " " + t.image;
		}
	|
		s = <GENOP> t = <_GENVALUE>
		{
			return realName + " " + s.image + " " + t.image;
		}
	|
		<RLIKE> s = <_TEXTVALUE>
		{
			return realName + " REGEXP " + s.image;
		}
	|
		<LIKE> s = <_TEXTVALUE>
		{
			return realName + " LIKE " + s.image;
		}
	}

void ParseSort() :
	{
		Token t;
		String order = "ASC";
	}
	{
		(
			<ASC> { }
		|
			<DESC> { order = "DESC"; }
		)?
		t = <SORT_NAME>
		{
			sortOrder = " ORDER BY " + getFieldName(t.image) + " " + order;
		}
	}

void ParseLimit() :
	{
		Token t1, t2;
	}
	{
		<LIMIT_OPENBRACKET> t1= <LIMIT_NUMVALUE>
		(
			<LIMIT_COMMA> t2 = <LIMIT_NUMVALUE> <LIMIT_CLOSEBRACKET>
			{
				limitTo = " LIMIT " + t1.image + ", " + t2.image;
			}
		|
			<LIMIT_CLOSEBRACKET>
			{
				limitTo = " LIMIT " + t1.image;
			}
		)
	}
