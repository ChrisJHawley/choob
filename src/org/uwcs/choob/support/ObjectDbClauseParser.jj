options {
	IGNORE_CASE = true;
	STATIC = false;
}

PARSER_BEGIN(ObjectDbClauseParser)
	package org.uwcs.choob.support;
	import java.util.Map;
	import java.util.List;
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.Iterator;
	import java.io.StringReader;

	public class ObjectDbClauseParser {
		private int joins = 0;
		private List joinList = new ArrayList();
		private Map nameMap = new HashMap();
		private String sortOrder = "";
		private String limitTo = "";
		private List classList = new ArrayList();
		private Map classMap = new HashMap();
		private Map fieldClass = new HashMap();

		public static void main(String args[])
		{
			try
			{
				for(int i=0; i<args.length; i++)
				{
					System.out.println(getSQL(args[i], args[++i]));
				}
			}
			catch (ParseException e)
			{
				System.out.println("Parse exception: " + e);
				e.printStackTrace();
			}
		}

		public static String getSQL(String clause, String className) throws ParseException {
			if (className == null)
				throw new IllegalArgumentException("Null class name passed to getSQL...");

			ObjectDbClauseParser parser = new ObjectDbClauseParser (new StringReader(clause));

			parser.classList.add(className);
			parser.classMap.put(className, new Integer(0));

			StringBuffer whereClause = new StringBuffer("("+parser.SQL()+")");
			StringBuffer joinText = new StringBuffer();
			for (int i=0; i<parser.classList.size(); i++)
			{
				String classN = (String)parser.classList.get(i);
				joinText.append("ObjectStore s"+i+" INNER JOIN ");
				whereClause.append(" && s"+i+".ClassName = \"" + classN + "\"");
			}
			for(int i=0; i<parser.joinList.size(); i++)
			{
				if (i != 0)
					joinText.append(" INNER JOIN ");
				String fullName = (String)parser.joinList.get(i);
				int pos = fullName.indexOf('.');
				String fieldName = fullName.substring(pos + 1);
				joinText.append("ObjectStoreData o" + i + " ON s"+parser.fieldClass.get(fullName)+".ObjectID = o" + i + ".ObjectID AND o" + i + ".FieldName = \"" + fieldName + "\"");
			}
			return "SELECT s0.ClassID FROM " + joinText.toString() + " WHERE " + whereClause.toString() + parser.sortOrder + parser.limitTo;
		}

		public String getFieldName(String name) throws ParseException
		{
			String fullName;
			if (name.indexOf('.') == -1)
				fullName = classList.get(0) + "." + name;
			else
				fullName = name;

			String realName = (String)nameMap.get(fullName.toLowerCase());
			if (realName != null)
				return realName;

			// Need to add!
			int pos = fullName.indexOf('.');
			String className = fullName.substring(0, pos);
			String fieldName = fullName.substring(pos + 1);

			Integer classID = (Integer)classMap.get(className);
			if (classID == null)
				throw new ParseException("Attempted to use a class not in a WITH clause...");

			realName = "o"+joinList.size()+".FieldValue";
			joinList.add(fullName.toLowerCase());
			fieldClass.put(fullName.toLowerCase(), classID);
			nameMap.put(fullName.toLowerCase(), realName);
			return realName;
		}
	}
PARSER_END(ObjectDbClauseParser)

<*>
SKIP: { " " | "\n" | "\t" }

// Definitions
TOKEN: {
	<#NUMVALUE: ( ["0"-"9"] ) + ( "." ( ["0"-"9"] ) + )?>
|	<#GENVALUE: <NUMVALUE> | <TEXTVALUE>>
|	<#TEXTVALUE: "\"" ( ~ ["\"", "\\"] | "\\" ~[] ) * "\"" | "'" ( ~ ["'", "\\"] | "\\" ~[] ) * "'">
|	<#NAME: ["a"-"z"] ( ["a"-"z", "0"-"9", "_"] )* >
|	<#FIELDNAME: <NAME> ("." <NAME>)* >
}

// Generic
TOKEN: {
	<WHERE: "WHERE"> : S_WHERE
|	<SORT: "SORT" ( " BY" )?> : S_SORT
|	<LIMIT: "LIMIT"> : S_LIMIT
|	<WITH: "WITH"> : S_WITH
}

<S_WHERE>
TOKEN: {
	<_OPENBRACKET: "("> : S_WHERE
|	<NOT: "!" | "NOT"> : S_WHERE
|	<WHERE_NAME: <FIELDNAME>> : S_OP
}

<S_NEXT>
TOKEN: {
	<_CLOSEBRACKET: ")"> : S_NEXT
|	<AND: "AND" | "&&"> : S_WHERE
|	<OR: "OR" | "||"> : S_WHERE
}

<S_SORT>
TOKEN: {
	<ASC: "ASC"> : S_SORT
|	<DESC: "DESC"> : S_SORT
|	<INTEGER: "INTEGER"> : S_SORT
|	<SORT_NAME: <NAME>> : DEFAULT
}

<S_LIMIT>
TOKEN: {
	<LIMIT_OPENBRACKET: "("> : S_LIMIT2
}

<S_LIMIT2>
TOKEN: {
	<LIMIT_NUMVALUE: <NUMVALUE>> : S_LIMIT3
}

<S_LIMIT3>
TOKEN: {
	<LIMIT_COMMA: ","> : S_LIMIT2
|	<LIMIT_CLOSEBRACKET: ")"> : DEFAULT
}

<S_WITH>
TOKEN: {
	<WITH_NAME: <NAME>> : DEFAULT
}

<S_NUMVALUE>
TOKEN: {
	<_NUMVALUE: <NUMVALUE>> : S_NEXT
|	<NUM_FIELDNAME: <FIELDNAME>> : S_NEXT
}

<S_GENVALUE>
TOKEN: {
	<_GENVALUE: <GENVALUE>> : S_NEXT
|	<GEN_FIELDNAME: <FIELDNAME>> : S_NEXT
}

<S_TEXTVALUE>
TOKEN: {
	<_TEXTVALUE: <TEXTVALUE>> : S_NEXT
|	<TEXT_FIELDNAME: <FIELDNAME>> : S_NEXT
}

<S_OP>
TOKEN: {
	<NUMOP: "<" | ">"> : S_NUMVALUE
|	<GENOP: "=" | "!="> : S_GENVALUE
|	<RLIKE: "RLIKE" | "REGEXP" | "~"> : S_TEXTVALUE
|	<LIKE: "LIKE"> : S_TEXTVALUE
}

String SQL () :
	{
		String s;
		StringBuffer b = new StringBuffer();
	}
	{
		(
			<WITH> ParseWith()
			{ }
		|
			<SORT> ParseSort()
			{ }
		|
			<LIMIT> ParseLimit()
			{ }
		|
			<WHERE> s = ClauseList()
			{ b.append(s); }
		)*
		{ return b.toString(); }
	}

/*
	ClauseList() = Clause() ClauseExtra()
*/
String ClauseExtra () :
	{
		String s;
		StringBuffer t = new StringBuffer();
	}
	{
		(
			<AND> s = Clause()
			{
				 t.append(" AND " + s);
			}
		|
			<OR> s = Clause()
			{
				t.append(" OR " + s);
			}
		)*
		{
			return t.toString();
		}
	}

String ClauseList () :
	{
		String s, t;
	}
	{
		s = Clause() t = ClauseExtra()
		{
			return s + t;
		}
	}

String Clause() :
	{
		java.util.Vector list;
		String s;
		Token t;
		int i;
	}
	{
		<NOT> s = Clause()
		{
			return "NOT " + s;
		}
	|
		t = <WHERE_NAME> s = OperatorAndValue(t.image)
		{
			return s;
		}
	|
		<_OPENBRACKET> s = ClauseList() <_CLOSEBRACKET>
		{
			return "(" + s + ")";
		}
	}

String OperatorAndValue(String name) :
	{
		String realName = getFieldName(name);
		Token s, t;
		String n;
	}
	{
		s = <NUMOP>
		(
			t = <_NUMVALUE> { n = t.image; }
		|	t = <NUM_FIELDNAME> { n = getFieldName(t.image); }
		)
		{
			return realName + " " + s.image + " " + n;
		}
	|
		s = <GENOP>
		(
			t = <_GENVALUE> { n = t.image; }
		|	t = <GEN_FIELDNAME> { n = getFieldName(t.image); }
		)
		{
			return realName + " " + s.image + " " + n;
		}
	|
		<RLIKE>
		(
			t = <_TEXTVALUE> { n = t.image; }
		|	t = <TEXT_FIELDNAME> { n = getFieldName(t.image); }
		)
		{
			return realName + " REGEXP " + n;
		}
	|
		<LIKE>
		(
			t = <_TEXTVALUE> { n = t.image; }
		|	t = <TEXT_FIELDNAME> { n = getFieldName(t.image); }
		)
		{
			return realName + " LIKE " + n;
		}
	}

void ParseSort() :
	{
		Token t;
		String order = "ASC";
		String modpre = "";
		String modpost = "";
	}
	{
		(
			<ASC> { }
		|
			<DESC> { order = "DESC"; }
		)?
		(
			<INTEGER> { modpre = " CAST( "; modpost = " AS SIGNED) "; }
		)?
		t = <SORT_NAME>
		{
			sortOrder = " ORDER BY " + modpre + getFieldName(t.image) + modpost + " " + order;
		}
	}

void ParseLimit() :
	{
		Token t1, t2;
	}
	{
		<LIMIT_OPENBRACKET> t1 = <LIMIT_NUMVALUE>
		(
			<LIMIT_COMMA> t2 = <LIMIT_NUMVALUE> <LIMIT_CLOSEBRACKET>
			{
				limitTo = " LIMIT " + t1.image + ", " + t2.image;
			}
		|
			<LIMIT_CLOSEBRACKET>
			{
				limitTo = " LIMIT " + t1.image;
			}
		)
	}

void ParseWith() :
	{
		Token t;
	}
	{
		t = <WITH_NAME> {
			if (classMap.get(t.image) == null)
			{
				classMap.put(t.image, classList.size());
				classList.add(t.image);
			}
		}
	}
