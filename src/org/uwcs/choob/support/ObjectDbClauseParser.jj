options {
	IGNORE_CASE = true;
	STATIC = false;
}

PARSER_BEGIN(ObjectDbClauseParser)
	package org.uwcs.choob.support;
	import java.util.Map;
	import java.util.List;
	import java.util.LinkedList;
	import java.util.HashMap;
	import java.util.Iterator;
	import java.io.StringReader;

	public class ObjectDbClauseParser {
		private Map nameMap;
		private int joins;
		private List joinList;

		public static void main(String args[])
		{
			try
			{
				for(int i=0; i<args.length; i++)
					System.out.println(getSQL(args[i]));
			}
			catch (ParseException e)
			{
				System.out.println("Parse exception: " + e);
				e.printStackTrace();
			}
		}

		public static String getSQL(String clause) throws ParseException {
			ObjectDbClauseParser parser = new ObjectDbClauseParser (new StringReader(clause));

			parser.joins = 0;
			parser.nameMap = new HashMap();
			parser.joinList = new LinkedList();

			String whereClause = parser.ClauseList();
			StringBuffer joinText = new StringBuffer();
			Iterator l = parser.joinList.listIterator();
			int i = 0;
			while( l.hasNext() )
			{
				String fieldName = (String)l.next();
				joinText.append("INNER JOIN ObjectStoreData o" + i + " ON ObjectStore.ObjectID = o" + i + ".ObjectID AND o" + i + ".FieldName = \"" + fieldName + "\" ");
				i++;
			}
			return joinText.toString() + "WHERE " + whereClause;
		}

		public String getFieldName(String name)
		{
			String realName = (String)nameMap.get(name.toLowerCase());
			if (realName != null)
				return realName;
			// Need to add!
			realName = "o"+joins+".FieldValue";
			joinList.add(name.toLowerCase());
			joins++;
			nameMap.put(name.toLowerCase(), realName);
			return realName;
		}
	}
PARSER_END(ObjectDbClauseParser)

<*>
SKIP: { " " | "\n" | "\t" }

TOKEN: {
	<OPENBRACKET: "("> : DEFAULT
|	<NOT: "!" | "NOT"> : DEFAULT
|	<NAME: ["a"-"z"] ( ["a"-"z", "0"-"9", "_"] )* > : S_OP
}

<S_NUMVALUE>
TOKEN: {
	<NUMVALUE: ( ["0"-"9"] ) + > : S_NEXT
}

<S_GENVALUE>
TOKEN: {
	<GENVALUE: ( ["0"-"9"] ) + | "\"" ( ~ ["\"", "\\"] | "\\" ~[] ) * "\"" | "'" ( ~ ["'", "\\"] | "\\" ~[] ) * "'"> : S_NEXT
}

<S_TEXTVALUE>
TOKEN: {
	<TEXTVALUE: "\"" ( ~ ["\"", "\\"] | "\\" ~[] ) * "\"" | "'" ( ~ ["'", "\\"] | "\\" ~[] ) * "'"> : S_NEXT
}

<S_OP>
TOKEN: {
	<NUMOP: "<" | ">"> : S_NUMVALUE
|	<GENOP: "=" | "!="> : S_GENVALUE
|	<RLIKE: "RLIKE" | "REGEXP" | "~"> : S_TEXTVALUE
|	<LIKE: "LIKE"> : S_TEXTVALUE
}

<S_NEXT>
TOKEN: {
	<CLOSEBRACKET: ")"> : S_NEXT
|	<AND: "AND" | "&&"> : DEFAULT
|	<OR: "OR" | "||"> : DEFAULT
}

/*
	ClauseList() = Clause() ClauseExtra()
*/
String ClauseExtra () :
	{
		String s;
		StringBuffer t = new StringBuffer();
	}
	{
		(
			<AND> s = Clause()
			{
				 t.append(" AND " + s);
			}
		|
			<OR> s = Clause()
			{
				t.append(" OR " + s);
			}
		)*
		{
			return t.toString();
		}
	}

String ClauseList () :
	{
		String s, t;
	}
	{
		s = Clause() t = ClauseExtra()
		{
			return s + t;
		}
	}

String Clause() :
	{
		java.util.Vector list;
		String s;
		Token t;
		int i;
	}
	{
		<NOT> s = Clause()
		{
			return "NOT " + s;
		}
	|
		t = <NAME> s = OperatorAndValue(t.image)
		{
			return s;
		}
	|
		<OPENBRACKET> s = ClauseList() <CLOSEBRACKET>
		{
			return "(" + s + ")";
		}
	}

String OperatorAndValue(String name) :
	{
		String realName = getFieldName(name);
		Token s, t;
	}
	{
		s = <NUMOP> t = <NUMVALUE>
		{
			return realName + " " + s.image + " " + t.image;
		}
	|
		s = <GENOP> t = <GENVALUE>
		{
			return realName + " " + s.image + " " + t.image;
		}
	|
		<RLIKE> s = <TEXTVALUE>
		{
			return realName + " REGEXP " + s.image;
		}
	|
		<LIKE> s = <TEXTVALUE>
		{
			return realName + " LIKE " + s.image;
		}
	}
