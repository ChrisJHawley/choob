/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. org/uwcs/choob/support/ObjectDbClauseParser.jj */
/*@egen*/options {
	IGNORE_CASE = true;
	STATIC = false;                                                                                                                             
}

PARSER_BEGIN(ObjectDbClauseParser)
	package org.uwcs.choob.support;
	import java.util.Map;
	import java.util.List;
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.Iterator;
	import java.io.StringReader;

	public class ObjectDbClauseParser/*@bgen(jjtree)*/implements ObjectDbClauseParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTObjectDbClauseParserState jjtree = new JJTObjectDbClauseParserState();

/*@egen*/
		private int joins = 0;
		private List joinList = new ArrayList();  // List of properties to join on.
		private Map nameMap = new HashMap();      // List of indices into joinList for join names.
		private List classList = new ArrayList(); // List of classes used.
		private Map classMap = new HashMap();     // Map of alias name -> classList offset.
		private Map fieldClass = new HashMap();   // Map of field name -> classList offset.
		private List modifiedClasses = new ArrayList(); // List of classes modified.
		private String joinWhere = null;

		// Negative values indicate nonspecific types.
		public final static int
			HINT_NUMERIC = -1,
			HINT_UNKNOWN = 0,
			HINT_INTEGER = 1,
			HINT_FLOAT = 2,
			HINT_ID = 3,
			HINT_STRING = 4,
			HINT_BOOLEAN = 5;

		private int type = TYPE_UNKNOWN;

		public final static int
			TYPE_UNKNOWN = 0,
			TYPE_SELECT = 1,
			TYPE_UPDATE = 2,
			TYPE_DELETE = 3,
			TYPE_INSERT = 4;

		public ObjectDbClauseParser(String clause, String className)
		{
			this(new StringReader(clause));
			classList.add(className);
			classMap.put(className.toLowerCase(), new Integer(0));
		}

		public static void main(String args[])
		{
			try
			{
				for(int i=0; i<args.length; i++)
				{
					System.out.println(getSQL(args[i], args[++i]));
				}
			}
			catch (ParseException e)
			{
				System.out.println("Parse exception: " + e);
				e.printStackTrace();
			}
		}

		public static String getSQL(String clause, String className) throws ParseException
		{
			if (className == null)
				throw new IllegalArgumentException("Null class name passed to getSQL...");

			ObjectDbClauseParser parser = new ObjectDbClauseParser (clause, className);

			return parser.ODBExpr();
		}

		/**
		 * Gets the type of this query (TYPE_SELECT, ...)
		 */
		public int getType()
		{
			return type;
		}

		/**
		 * For a modification statement, returns the classes which may be altered.
		 */
		public List getModifiedClasses()
		{
			return modifiedClasses;
		}

		/**
		 * Returns the classes which may be read from.
		 */
		public List getUsedClasses()
		{
			return classList;
		}

		public String getTableJoin()
		{
			StringBuffer joinText = new StringBuffer();
			StringBuffer whereText = new StringBuffer("(1");
			for (int i=0; i<classList.size(); i++)
			{
				String classN = (String)classList.get(i);
				joinText.append("ObjectStore s"+i);
				whereText.append(" AND s"+i+".ClassName = \"" + classN + "\"");
				if (i < classList.size() - 1)
					joinText.append(" INNER JOIN ");
			}
			for (int i=0; i<joinList.size(); i++)
			{
				joinText.append(" INNER JOIN ");
				String fullName = (String)joinList.get(i);
				int pos = fullName.lastIndexOf('.');
				String fieldName = fullName.substring(pos + 1);
				joinText.append("ObjectStoreData o" + i + " ON s"+fieldClass.get(fullName)+".ObjectID = o" + i + ".ObjectID AND o" + i + ".FieldName = \"" + fieldName + "\"");
			}
			whereText.append(")");
			joinWhere = whereText.toString();
			return joinText.toString();
		}

		public String getFieldName(String name) throws ParseException
		{
			String fullName;
			if (name.lastIndexOf('.') == -1)
				fullName = (classList.get(0) + "." + name).toLowerCase();
			else
				fullName = name.toLowerCase();

			String realName = (String)nameMap.get(fullName);
			if (realName != null)
				return realName;

			// Need to add!
			int pos = fullName.lastIndexOf('.');
			String className = fullName.substring(0, pos);
			String fieldName = fullName.substring(pos + 1);

			Integer classID = (Integer)classMap.get(className);
			if (classID == null)
				throw new ParseException("Attempted to use a class not in a WITH clause...");

			if (fieldName.equals("id")) 
				// Special case, no join required...
				realName = "s"+classID+".ClassID";
			else
			{
				realName = "o"+joinList.size();
				joinList.add(fullName);
				fieldClass.put(fullName, classID);
			}

			nameMap.put(fullName, realName);
			return realName;
		}

		public String parseExpression(SimpleNode expr, int hint) throws ParseException
		{
			// Note that hint is now a solid hint: We can safely assume it as
			// the type for anything without an override.
			if (expr instanceof ObjectDBClauseNodeRoot)
			{
				StringBuffer buf = new StringBuffer();
				if(expr.jjtGetNumChildren() != 1)
					throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
				return parseExpression((SimpleNode)expr.jjtGetChild(0), hint);
			}
			else if (expr instanceof ObjectDBClauseNodeExpressionList)
			{
				StringBuffer buf = new StringBuffer();
				for(int i=0; i<expr.jjtGetNumChildren(); i++)
				{
					if (i != 0)
						buf.append(", ");
					buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
				}
				return buf.toString();
			}
			else if (expr instanceof ObjectDBClauseNodeFunction)
			{
				StringBuffer buf = new StringBuffer(expr.getName()+"(");
				for(int i=0; i<expr.jjtGetNumChildren(); i++)
				{
					if (i != 0)
						buf.append(", ");
					buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
				}
				buf.append(")");
				return buf.toString();
			}
			else if (expr instanceof ObjectDBClauseNodeAdd)
			{
				StringBuffer buf = new StringBuffer();
				for(int i=0; i<expr.jjtGetNumChildren(); i++)
				{
					if (i != 0)
						buf.append(" + ");
					buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
				}
				return buf.toString();
			}
			else if (expr instanceof ObjectDBClauseNodeMul)
			{
				StringBuffer buf = new StringBuffer();
				for(int i=0; i<expr.jjtGetNumChildren(); i++)
				{
					if (i != 0)
						buf.append(" * ");
					buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
				}
				return buf.toString();
			}
			else if (expr instanceof ObjectDBClauseNodeConstant)
			{
				return expr.getName();
			}
			else if (expr instanceof ObjectDBClauseNodeField)
			{
				// The only really tricky one...
				int thingHint = expr.getHint() != 0 ? expr.getHint() : hint;
				if (thingHint == 0)
					thingHint = HINT_STRING;
				String prefix = getFieldName(expr.getName());
				if (thingHint == HINT_INTEGER)
					return prefix + ".FieldBigInt";
				else if (thingHint == HINT_FLOAT)
					return prefix + ".FieldDouble";
				else if (thingHint == HINT_BOOLEAN)
					return prefix + ".FieldBigInt"; // 1 for true, so all good
				else if (thingHint == HINT_STRING)
					return prefix + ".FieldString";
				else if (thingHint == HINT_ID)
					return prefix; // Special case; id fields are stored as the full name anyway.
			}
			throw new ParseException("Could not parse node of type " + expr.getClass().getSimpleName() + " with hint " + hint + " into column name.");
		}

		public int getHint(SimpleNode expr1, SimpleNode expr2, int hint) throws ParseException
		{
			// Try to get  hint from expr2, if that fails use expr1.
			return getHint(expr1, getHint(expr2, hint, true), false);
		}

		public int getHint(SimpleNode expr, int hint, boolean noResolve) throws ParseException
		{
			// If the hint is already "solid", just return.
			if (hint > 0)
				return hint;

			if (expr instanceof ObjectDBClauseNodeRoot)
			{
				StringBuffer buf = new StringBuffer();
				if(expr.jjtGetNumChildren() != 1)
					throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
				hint = getHint((SimpleNode)expr.jjtGetChild(0), hint, noResolve);
			}
			else if (expr instanceof ObjectDBClauseNodeAdd)
			{
				if(expr.jjtGetNumChildren() > 1)
					hint = HINT_NUMERIC; // We used maths!

				for(int i=0; i<expr.jjtGetNumChildren(); i++)
					hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
			}
			else if (expr instanceof ObjectDBClauseNodeMul)
			{
				if(expr.jjtGetNumChildren() > 1)
					hint = HINT_NUMERIC; // We used maths!

				for(int i=0; i<expr.jjtGetNumChildren(); i++)
					hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
			}
			else if (expr instanceof ObjectDBClauseNodeConstant)
			{
				hint = expr.getHint();
			}
			else if (expr instanceof ObjectDBClauseNodeField)
			{
				// The only really tricky one...
				int newHint = expr.getHint();
				if (newHint < 0 && hint == 0)
					hint = expr.getHint();
				else if (newHint > 0)
					if (newHint != HINT_ID)
						hint = expr.getHint();
					else
						hint = HINT_INTEGER;
			}

			// If we haven't finished processing, just return current hint.
			if (noResolve || hint > 0)
				return hint;

			// Otherwise, make the most "general" solid hint we can.
			if (hint == HINT_NUMERIC)
				return HINT_FLOAT;
			else
				return HINT_STRING;
		}

		public String join(List list)
		{
			if (list.size() == 0)
				return "";
			StringBuffer buf = new StringBuffer();
			boolean first = true;
			Iterator it = list.iterator();
			while(it.hasNext())
			{
				if (first)
					first = false;
				else
					buf.append(", ");
				buf.append((String)it.next());
			}
			return buf.toString();
		}
	}
PARSER_END(ObjectDbClauseParser)

<*>
SKIP: { " " | "\n" | "\t" }

// Definitions
TOKEN: {
	<#P_FLOATVALUE: ("-")? ( ["0"-"9"] ) + "." ( ["0"-"9"] ) +>
|	<#P_INTVALUE: ("-")? ( ["0"-"9"] ) + >
|	<#P_TEXTVALUE: "\"" ( ~ ["\"", "\\"] | "\\" ~[] ) * "\"" | "'" ( ~ ["'", "\\"] | "\\" ~[] ) * "'">
|	<#P_NAME: ["a"-"z"] ( ["a"-"z", "0"-"9", "_"] )* >
}

// Things

TOKEN: {
	<K_WHERE: "WHERE">
|	<K_SORT: "SORT" ( " BY" )? | "ORDER" ( " BY" )? >
|	<K_LIMIT: "LIMIT">

|	<K_WITH: "WITH">
|	<K_FROM: "FROM">
|	<K_SET: "SET">
|	<K_TABLE: "TABLE">
|	<K_INTO: "INTO">

|	<K_SELECT: "SELECT">
|	<K_INSERT: "INSERT">
|	<K_DELETE: "DELETE">
|	<K_UPDATE: "UPDATE">

|	<OPENBRACKET: "(">
|	<CLOSEBRACKET: ")">

|	<K_NOT: "!" | "NOT">
|	<K_AND: "AND" | "&&">
|	<K_OR: "OR" | "||">

|	<K_ASC: "ASC" | "ASCENDING">
|	<K_DESC: "DESC" | "DESCENDING">
|	<K_INTEGER: "INTEGER">
|	<K_RANDOM: "RANDOM" | "RAND">

|	<K_AS: "AS">

|	<K_0FUNC: "COUNT">
|	<K_1FUNC: "SUM">
|	<K_2FUNC: "SPAMANDEGGS">
|	<K_3FUNC: "CONCAT">

|	<K_LESS: "<">
|	<K_GREATER: ">">
|	<K_EQUAL: "=">
|	<K_NOTEQUAL: "!=">
|	<K_RLIKE: "RLIKE" | "REGEXP" | "~">
|	<K_LIKE: "LIKE">

|	<K_ADD: "+">
|	<K_SUBTRACT: "-">
|	<K_MULTIPLY: "*">
|	<K_DIVIDE: "/">

|	<COMMA: ",">

|	<K_ISINT: "ISINT">
|	<K_ISFLOAT: "ISFLOAT">
|	<K_ISSTR: "ISSTR" | "ISSTRING">
|	<K_ISBOOL: "ISBOOL">

|	<IDNAME: (<P_NAME> ("." <P_NAME>)* ".")? "id">
|	<FIELDNAME: <P_NAME> ("." <P_NAME>)* >
|	<TEXTVALUE: <P_TEXTVALUE>>
|	<FLOATVALUE: <P_FLOATVALUE>>
|	<INTVALUE: <P_INTVALUE>>
}

String ODBExpr () :
	{
		String s = null, t;
		StringBuffer b = new StringBuffer();
		SimpleNode l;
	}
	{
		(
			<K_SELECT> l = ExpressionList() t = ParseSelect(l)
			{ return t; }
		|
			<K_INSERT> t = ParseInsert()
			{ return t; }
		|
			<K_UPDATE> (<K_TABLE>) ?
			( s = ClassName() ) ?
			{
				if (s == null)
				{
					if (classList.size() > 0)
						s = (String)classList.get(0);
					else
						throw new ParseException("No class specified for classless UPDATE");
				}
			}
			t = ParseUpdate(s)
			{ return t; }
		|
			<K_DELETE> t = ParseDelete()
			{ return t; }
		|
			t = ParseSelect(null)
			{ return t; }
		)
	}

String ParseSelect(SimpleNode cols) :
	{
		String cls = null;
		if (classList.size() > 0)
			cls = (String)classList.get(0);

		String sort = "";
		String limit = "";
		String where = "1";

		String string;
		List stringList;
		SimpleNode l;
	}
	{
		(
			<K_WITH> string = ClassName()
			{
				if (cls == null)
					throw new ParseException("WITH clause used on a query which had no FROM class.");
				else
					cls = string;
			}
		|
			<K_FROM> stringList = ClassList()
			{
				if (cls == null)
					cls = (String)stringList.get(0);
				else
					throw new ParseException("FROM clause used on a query which already had a FROM class.");
			}
		|
			<K_SORT> string = ParseSort()
			{
				if (sort.equals(""))
					sort = " " + string;
				else
					throw new ParseException("Multiple SORT clauses.");
			}
		|
			<K_LIMIT> string = ParseLimit()
			{
				if (limit.equals(""))
					limit = " " + string;
				else
					throw new ParseException("Multiple LIMIT clauses.");
			}
		|
			<K_WHERE> string = ClauseOr()
			{
				if (where.equals("1"))
					where = string;
				else
					throw new ParseException("Multiple WHERE clauses.");
			}
		)*
		{
			if (cls == null)
				throw new ParseException("No FROM clause in SELECT statement.");

			type = TYPE_SELECT;

			String realCols = (cols == null ? "s0.ClassID" : parseExpression(cols, HINT_UNKNOWN));
			return "SELECT " + realCols + " FROM " + getTableJoin() + " WHERE " + where + " AND " + joinWhere + " GROUP BY s0.ClassID" + sort + limit;
		}
	}

String ParseUpdate(String cls) :
	{
		SimpleNode cols;
		String where = "1";
	}
	{
		<K_SET> cols = FieldSetList()
		(
			<K_WHERE> where = ClauseOr()
		)?
		{
			modifiedClasses.add(cls);
			type = TYPE_UPDATE;

			StringBuffer update = new StringBuffer();
			StringBuffer inserts = new StringBuffer();
			for(int i=0; i<cols.jjtGetNumChildren(); i++)
			{
				SimpleNode col = (SimpleNode)cols.jjtGetChild(i);
				if (i != 0)
					update.append(", ");
				String name = getFieldName(col.getName());
				inserts.append("INSERT IGNORE INTO ObjectStoreData SELECT ObjectID, \"" + col.getName() + "\", NULL, NULL, NULL FROM ObjectStore WHERE ClassName = \"" + cls + "\";\n");
				update.append(name + ".FieldString = " + parseExpression((SimpleNode)col.jjtGetChild(0), HINT_UNKNOWN) + ", ");
				update.append(name + ".FieldBigInt = " + name + ".FieldString, ");
				update.append(name + ".FieldDouble = " + name + ".FieldString");
			}
			update.append(" WHERE " + where + " AND " + joinWhere);
			inserts.append("UPDATE " + getTableJoin() + " SET " + update.toString());
			return inserts.toString();
		}
	}

String ParseInsert() :
	{
		String cls = null;
		if (classList.size() > 0)
			cls = (String)classList.get(0);

		String fields, string;
		SimpleNode cols;
	}
	{
		(
			<K_INTO> string = ClassName()
			{
				if (cls != null)
					cls = string;
				else
					throw new ParseException("INTO clause used on a query which already had an INTO class.");
			}
		)?
		<K_SET> cols = FieldSetList()
		{
			modifiedClasses.add(cls);
			type = TYPE_INSERT;

			String idClause = "DEFAULT";
			// Find an ID clause, if any...
			for(int i=0; i<cols.jjtGetNumChildren(); i++)
			{
				SimpleNode col = (SimpleNode)cols.jjtGetChild(i);
				if (col.getName().equalsIgnoreCase("id"))
					idClause = parseExpression((SimpleNode)col.jjtGetChild(0), HINT_UNKNOWN);
			}

			StringBuffer query = new StringBuffer("INSERT INTO ObjectStore VALUES(" + idClause + ", '" + cls + "', id);\n");
			for(int i=0; i<cols.jjtGetNumChildren(); i++)
			{
				SimpleNode col = (SimpleNode)cols.jjtGetChild(i);

				if (col.getName().equalsIgnoreCase("id"))
					continue;

				String value = parseExpression((SimpleNode)col.jjtGetChild(0), HINT_UNKNOWN);
				query.append("INSERT INTO ObjectStoreData VALUES(LAST_INSERT_ID(), \"" + col.getName() + "\", " + value + ", " + value + ", " + value + ");\n");
			}
			return query.toString();
		}
	}

String ParseDelete() :
	{
		String cls = null;
		if (classList.size() > 0)
			cls = (String)classList.get(0);

		String where = "1";
		String string;
	}
	{
		(
			<K_FROM> string = ClassName()
			{
				if (cls != null)
					cls = string;
				else
					throw new ParseException("FROM clause used on a query which already had a FROM class.");
			}
		)?
		(
			<K_WHERE> string = ClauseOr()
			{
				where = string;
			}
		)?
		{
			if (cls == null)
				throw new ParseException("No FROM clause in a DELETE.");

			modifiedClasses.add(cls);
			type = TYPE_DELETE;

			return "DELETE FROM s0 USING " + getTableJoin() + " WHERE " + where + " AND " + joinWhere;
		}
	}


/**
 * WHERE parser
 */
String ClauseOr () :
	{
		StringBuffer out = new StringBuffer();
		String clause;
	}
	{
// If we wanted trees here:
//		(
//			ClauseAnd() ( <K_OR> t = ClauseAnd() ) *
//		) #Or(>1)
		clause = ClauseAnd() { out.append(clause); }
		( <K_OR> clause = ClauseAnd() { out.append(" OR " + clause); } ) *
		{
			return out.toString();
		}
	}

String ClauseAnd () :
	{
		StringBuffer out = new StringBuffer();
		String clause;
	}
	{
// If we wanted trees here:
//		(
//			Clause() ( <K_AND> t = Clause() ) *
//		) #And(>1)
		clause = Clause() { out.append(clause); }
		( <K_AND> clause = Clause() { out.append(" AND " + clause); } ) *
		{
			return out.toString();
		}
	}

String Clause() :
	{
		java.util.Vector list;
		String s;
	}
	{
		<K_NOT> s = Clause()
		{
			return "NOT " + s;
		}
	|
		<OPENBRACKET> s = ClauseOr() <CLOSEBRACKET>
		{
			return "(" + s + ")";
		}
	|
		s = BoolExpression()
		{
			return s;
		}
	}

String BoolExpression() :
	{
		SimpleNode expr1, expr2 = null;
		String op = null;
		int hint = 0;
	}
	{
		// First, an expression
		expr1 = ExpressionRoot()

		(
			// Operator
			(
				<K_LESS> { op = "<"; hint = HINT_NUMERIC; }
			|
				<K_GREATER> { op = ">"; hint = HINT_NUMERIC; }
			|
				<K_EQUAL> { op = "="; }
			|
				<K_NOTEQUAL> { op = "="; }
			|
				<K_RLIKE> { op = "RLIKE"; hint = HINT_STRING; }
			|
				<K_LIKE> { op = "LIKE"; hint = HINT_STRING; }
			)
			expr2 = ExpressionRoot()
		)?
		{
			if ( expr2 == null )
				return parseExpression(expr1, HINT_BOOLEAN);

			else
			{
				// Attempt to mangle together a further hint, for example narrowing HINT_NUMERIC.
				hint = getHint(expr1, expr2, hint);
				return parseExpression(expr1, hint) + " " + op + " " + parseExpression(expr2, hint);
			}
		}
	}

String Expression(int hint) :
	{
		SimpleNode root;
	}
	{
		root = ExpressionRoot()
		{
			return parseExpression(root, hint);
		}
	}

SimpleNode ExpressionRoot()       : {/*@bgen(jjtree) Root */
  ObjectDBClauseNodeRoot jjtn000 = new ObjectDBClauseNodeRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
	{/*@bgen(jjtree) Root */
                try {
/*@egen*/
		ExpressionAdd()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			return jjtn000;
		}/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void ExpressionAdd() :
	{ }
	{/*@bgen(jjtree) #Add(> 1) */
                {
                  ObjectDBClauseNodeAdd jjtn001 = new ObjectDBClauseNodeAdd(JJTADD);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(
			ExpressionMul()
			(
				( <K_ADD> | <K_SUBTRACT> ) ExpressionMul()
			) *
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
                }
/*@egen*/
	}

void ExpressionMul() : { }
	{/*@bgen(jjtree) #Mul(> 1) */
                {
                  ObjectDBClauseNodeMul jjtn001 = new ObjectDBClauseNodeMul(JJTMUL);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(
			ExpressionUnit()
			(
				( <K_MULTIPLY> | <K_DIVIDE> ) ExpressionUnit()
			) *
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
                }
/*@egen*/
	}

void ExpressionUnit() : { Token t; }
	{
		( <OPENBRACKET> ExpressionAdd() <CLOSEBRACKET> )
	|
		<K_ISINT> <OPENBRACKET> Field(HINT_INTEGER) <CLOSEBRACKET>
	|
		<K_ISFLOAT> <OPENBRACKET> Field(HINT_FLOAT) <CLOSEBRACKET>
	|
		<K_ISSTR> <OPENBRACKET> Field(HINT_STRING) <CLOSEBRACKET>
	|
		<K_ISBOOL> <OPENBRACKET> Field(HINT_BOOLEAN) <CLOSEBRACKET>
	|
		t = <K_0FUNC> Function(t.image, 0)
	|
		t = <K_1FUNC> Function(t.image, 1)
	|
		t = <K_2FUNC> Function(t.image, 2)
	|
		t = <K_3FUNC> Function(t.image, 3)
	|
		Field(0)
	|
		Constant()
	}

void Function(String name, int params)           : {/*@bgen(jjtree) Function */
                                                     ObjectDBClauseNodeFunction jjtn000 = new ObjectDBClauseNodeFunction(JJTFUNCTION);
                                                     boolean jjtc000 = true;
                                                     jjtree.openNodeScope(jjtn000);
/*@egen*/ SimpleNode n; }
	{/*@bgen(jjtree) Function */
                try {
/*@egen*/
		<OPENBRACKET>
		n = ExpressionList()
		<CLOSEBRACKET>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			if (n.jjtGetNumChildren() != params)
				throw new ParseException("Wrong number of parameters for " + name + "!");
			jjtn000.setName(name);
		}/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void Constant()           :
	{/*@bgen(jjtree) Constant */
                ObjectDBClauseNodeConstant jjtn000 = new ObjectDBClauseNodeConstant(JJTCONSTANT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/
		Token value;
		int hint;
	}
	{/*@bgen(jjtree) Constant */
                try {
/*@egen*/
		(
			value = <TEXTVALUE>
			{
				hint = HINT_STRING;
			}
		|
			value = <FLOATVALUE>
			{
				hint = HINT_FLOAT;
			}
		|
			value = <INTVALUE>
			{
				hint = HINT_INTEGER;
			}
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			jjtn000.setName(value.image);
			jjtn000.setHint(hint);
		}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void Field(int hint)        :
	{/*@bgen(jjtree) Field */
                ObjectDBClauseNodeField jjtn000 = new ObjectDBClauseNodeField(JJTFIELD);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/
		Token name;
	}
	{/*@bgen(jjtree) Field */
                try {
/*@egen*/
		name = <IDNAME>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			jjtn000.setName(name.image);
			jjtn000.setHint(HINT_ID);
		}
	|
		name = <FIELDNAME>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			jjtn000.setName(name.image);
			jjtn000.setHint(hint);
		}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

String ClassName() :
	{
		Token cls, name = null;
	}
	{
		cls = <FIELDNAME>
		( (<K_AS>)? name = <FIELDNAME> )?
		{
			if (name == null)
				name = cls;

			if (classMap.get(name.image.toLowerCase()) == null)
			{
				classMap.put(name.image.toLowerCase(), classList.size());
				classList.add(cls.image);
			}

			return cls.image;
		}
	}

List ClassList() :
	{
		List list = new ArrayList();
		String string;
	}
	{
		string = ClassName()
		{ list.add(string); }
		(
			<COMMA> string = ClassName()
			{ list.add(string); }
		)*
		{ return list; }
	}

SimpleNode ExpressionList()                 :
	{/*@bgen(jjtree) ExpressionList */
  ObjectDBClauseNodeExpressionList jjtn000 = new ObjectDBClauseNodeExpressionList(JJTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
	}
	{/*@bgen(jjtree) ExpressionList */
                try {
/*@egen*/
		ExpressionRoot()
		(
			<COMMA> ExpressionRoot()
		)*/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ jjtn000.setName(""); return jjtn000; }/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

void FieldSet()           :
	{/*@bgen(jjtree) FieldSet */
                ObjectDBClauseNodeFieldSet jjtn000 = new ObjectDBClauseNodeFieldSet(JJTFIELDSET);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/
		List list = new ArrayList();
		String expr;
		Token fieldName;
	}
	{/*@bgen(jjtree) FieldSet */
                try {
/*@egen*/
		fieldName = <FIELDNAME>
		{ jjtn000.setName(fieldName.image); }
		<K_EQUAL>
		ExpressionRoot()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

SimpleNode FieldSetList()               :
	{/*@bgen(jjtree) FieldSetList */
                ObjectDBClauseNodeFieldSetList jjtn000 = new ObjectDBClauseNodeFieldSetList(JJTFIELDSETLIST);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/
		List list = new ArrayList();
		String string;
	}
	{/*@bgen(jjtree) FieldSetList */
                try {
/*@egen*/
		FieldSet()
		( <COMMA> FieldSet() )*/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ return jjtn000; }/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
	}

String ParseSort() :
	{
		Token t;
		String order = "ASC";
		boolean isInt = false;
	}
	{
		(
			(
				<K_ASC> { }
			|
				<K_DESC> { order = "DESC"; }
			)?
			(
				<K_INTEGER> { isInt = true; }
			)?
			t = <FIELDNAME>
			{
				String suffix = isInt ? ".FieldBigInt" : ".FieldString";
				return "ORDER BY " + getFieldName(t.image) + suffix + " " + order;
			}
		|
			<K_RANDOM>
			{
				return "ORDER BY RAND()";
			}
		)
	}

String ParseLimit() :
	{
		Token t1, t2;
	}
	{
		<OPENBRACKET> t1 = <INTVALUE>
		(
			<COMMA> t2 = <INTVALUE> <CLOSEBRACKET>
			{
				return "LIMIT " + t1.image + ", " + t2.image;
			}
		|
			<CLOSEBRACKET>
			{
				return "LIMIT " + t1.image;
			}
		)
	}
