/* Generated By:JJTree&JavaCC: Do not edit this line. ObjectDbClauseParser.java */
        package org.uwcs.choob.support;
        import java.util.Map;
        import java.util.List;
        import java.util.ArrayList;
        import java.util.HashMap;
        import java.util.Iterator;
        import java.io.StringReader;

        public class ObjectDbClauseParser/*@bgen(jjtree)*/implements ObjectDbClauseParserTreeConstants, ObjectDbClauseParserConstants {/*@bgen(jjtree)*/
  protected JJTObjectDbClauseParserState jjtree = new JJTObjectDbClauseParserState();private int joins = 0;
                private List joinList = new ArrayList();
                private Map nameMap = new HashMap();
                private String sortOrder = "";
                private String limitTo = "";
                private String selClause = "s0.ClassID";
                private List classList = new ArrayList();
                private Map classMap = new HashMap();
                private Map fieldClass = new HashMap();

                // Negative values indicate nonspecific types.
                private static final int
                        HINT_NUMERIC = -1,
                        HINT_INTEGER = 1,
                        HINT_FLOAT = 2,
                        HINT_ID = 3,
                        HINT_STRING = 4,
                        HINT_BOOLEAN = 5;

                public static void main(String args[])
                {
                        try
                        {
                                for(int i=0; i<args.length; i++)
                                {
                                        System.out.println(getSQL(args[i], args[++i]));
                                }
                        }
                        catch (ParseException e)
                        {
                                System.out.println("Parse exception: " + e);
                                e.printStackTrace();
                        }
                }

                public static String getSQL(String clause, String className) throws ParseException {
                        if (className == null)
                                throw new IllegalArgumentException("Null class name passed to getSQL...");

                        ObjectDbClauseParser parser = new ObjectDbClauseParser (new StringReader(clause));

                        parser.classList.add(className);
                        parser.classMap.put(className.toLowerCase(), new Integer(0));

                        StringBuffer whereClause = new StringBuffer("("+parser.SQL()+")");
                        StringBuffer joinText = new StringBuffer();
                        for (int i=0; i<parser.classList.size(); i++)
                        {
                                String classN = (String)parser.classList.get(i);
                                joinText.append("ObjectStore s"+i);
                                whereClause.append(" && s"+i+".ClassName = \"" + classN + "\"");
                                if (i < parser.classList.size() - 1)
                                        joinText.append(" INNER JOIN ");
                        }
                        for(int i=0; i<parser.joinList.size(); i++)
                        {
                                joinText.append(" INNER JOIN ");
                                String fullName = (String)parser.joinList.get(i);
                                int pos = fullName.lastIndexOf('.');
                                String fieldName = fullName.substring(pos + 1);
                                joinText.append("ObjectStoreData o" + i + " ON s"+parser.fieldClass.get(fullName)+".ObjectID = o" + i + ".ObjectID AND o" + i + ".FieldName = \"" + fieldName + "\"");
                        }
                        return "SELECT " + parser.selClause + " FROM " + joinText.toString() + " WHERE " + whereClause.toString() + " GROUP BY s0.ClassID " + parser.sortOrder + parser.limitTo;
                }

                public String getFieldName(String name) throws ParseException
                {
                        String fullName;
                        if (name.lastIndexOf('.') == -1)
                                fullName = (classList.get(0) + "." + name).toLowerCase();
                        else
                                fullName = name.toLowerCase();

                        String realName = (String)nameMap.get(fullName);
                        if (realName != null)
                                return realName;

                        // Need to add!
                        int pos = fullName.lastIndexOf('.');
                        String className = fullName.substring(0, pos);
                        String fieldName = fullName.substring(pos + 1);

                        Integer classID = (Integer)classMap.get(className);
                        if (classID == null)
                                throw new ParseException("Attempted to use a class not in a WITH clause...");

                        if (fieldName.equals("id"))
                                // Special case, no join required...
                                realName = "s"+classID+".ClassID";
                        else
                        {
                                realName = "o"+joinList.size();
                                joinList.add(fullName);
                                fieldClass.put(fullName, classID);
                        }

                        nameMap.put(fullName, realName);
                        return realName;
                }

                public String parseExpression(SimpleNode expr, int hint) throws ParseException
                {
                        // Note that hint is now a solid hint: We can safely assume it as
                        // the type for anything without an override.
                        if (expr instanceof ObjectDBClauseNodeRoot)
                        {
                                StringBuffer buf = new StringBuffer();
                                if(expr.jjtGetNumChildren() != 1)
                                        throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
                                return parseExpression((SimpleNode)expr.jjtGetChild(0), hint);
                        }
                        else if (expr instanceof ObjectDBClauseNodeAdd)
                        {
                                StringBuffer buf = new StringBuffer();
                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                {
                                        if (i != 0)
                                                buf.append(" + ");
                                        buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
                                }
                                return buf.toString();
                        }
                        else if (expr instanceof ObjectDBClauseNodeMul)
                        {
                                StringBuffer buf = new StringBuffer();
                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                {
                                        if (i != 0)
                                                buf.append(" * ");
                                        buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
                                }
                                return buf.toString();
                        }
                        else if (expr instanceof ObjectDBClauseNodeConstant)
                        {
                                return expr.getName();
                        }
                        else if (expr instanceof ObjectDBClauseNodeField)
                        {
                                // The only really tricky one...
                                int thingHint = expr.getHint() != 0 ? expr.getHint() : hint;
                                String prefix = expr.getName();
                                if (thingHint == HINT_INTEGER)
                                        return prefix + ".FieldBigInt";
                                else if (thingHint == HINT_FLOAT)
                                        return prefix + ".FieldDouble";
                                else if (thingHint == HINT_BOOLEAN)
                                        return prefix + ".FieldBigInt"; // 1 for true, so all good
                                else if (thingHint == HINT_STRING)
                                        return prefix + ".FieldString";
                                else if (thingHint == HINT_ID)
                                        return prefix; // Special case; id fields are stored as the full name anyway.
                        }
                        throw new ParseException("Could not parse node of type " + expr.getClass().getSimpleName() + " with hint " + hint + " into column name.");
                }

                public int getHint(SimpleNode expr1, SimpleNode expr2, int hint) throws ParseException
                {
                        // Try to get  hint from expr2, if that fails use expr1.
                        return getHint(expr1, getHint(expr2, hint, true), false);
                }

                public int getHint(SimpleNode expr, int hint, boolean noResolve) throws ParseException
                {
                        // If the hint is already "solid", just return.
                        if (hint > 0)
                                return hint;

                        if (expr instanceof ObjectDBClauseNodeRoot)
                        {
                                StringBuffer buf = new StringBuffer();
                                if(expr.jjtGetNumChildren() != 1)
                                        throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
                                hint = getHint((SimpleNode)expr.jjtGetChild(0), hint, noResolve);
                        }
                        else if (expr instanceof ObjectDBClauseNodeAdd)
                        {
                                if(expr.jjtGetNumChildren() > 1)
                                        hint = HINT_NUMERIC; // We used maths!

                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                        hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
                        }
                        else if (expr instanceof ObjectDBClauseNodeMul)
                        {
                                if(expr.jjtGetNumChildren() > 1)
                                        hint = HINT_NUMERIC; // We used maths!

                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                        hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
                        }
                        else if (expr instanceof ObjectDBClauseNodeConstant)
                        {
                                hint = expr.getHint();
                        }
                        else if (expr instanceof ObjectDBClauseNodeField)
                        {
                                // The only really tricky one...
                                int newHint = expr.getHint();
                                if (newHint < 0 && hint == 0)
                                        hint = expr.getHint();
                                else if (newHint > 0)
                                        if (newHint != HINT_ID)
                                                hint = expr.getHint();
                                        else
                                                hint = HINT_INTEGER;
                        }

                        // If we haven't finished processing, just return current hint.
                        if (noResolve || hint > 0)
                                return hint;

                        // Otherwise, make the most "general" solid hint we can.
                        if (hint == HINT_NUMERIC)
                                return HINT_FLOAT;
                        else
                                return HINT_STRING;
                }

  final public String SQL() throws ParseException {
                String s;
                StringBuffer b = new StringBuffer();
                boolean clause = false;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_WHERE:
      case K_SORT:
      case K_LIMIT:
      case K_WITH:
      case K_SELECT:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_WITH:
        jj_consume_token(K_WITH);
        ParseWith();

        break;
      case K_SORT:
        jj_consume_token(K_SORT);
        ParseSort();

        break;
      case K_LIMIT:
        jj_consume_token(K_LIMIT);
        ParseLimit();

        break;
      case K_SELECT:
        jj_consume_token(K_SELECT);
        ParseSelect();

        break;
      case K_WHERE:
        jj_consume_token(K_WHERE);
        s = ClauseOr();
                                clause = true;
                                b.append(s);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                  {if (true) return clause ? b.toString() : "1";}
    throw new Error("Missing return statement in function");
  }

  final public String ClauseOr() throws ParseException {
                StringBuffer out = new StringBuffer();
                String clause;
    // If we wanted trees here:
    //		(
    //			ClauseAnd() ( <K_OR> t = ClauseAnd() ) *
    //		) #Or(>1)
                    clause = ClauseAnd();
                                       out.append(clause);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_OR:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      jj_consume_token(K_OR);
      clause = ClauseAnd();
                                                out.append(" OR " + clause);
    }
                        {if (true) return out.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String ClauseAnd() throws ParseException {
                StringBuffer out = new StringBuffer();
                String clause;
    // If we wanted trees here:
    //		(
    //			Clause() ( <K_AND> t = Clause() ) *
    //		) #And(>1)
                    clause = Clause();
                                    out.append(clause);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_AND:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      jj_consume_token(K_AND);
      clause = Clause();
                                              out.append(" AND " + clause);
    }
                        {if (true) return out.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String Clause() throws ParseException {
                java.util.Vector list;
                String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOT:
      jj_consume_token(K_NOT);
      s = Clause();
                        {if (true) return "NOT " + s;}
      break;
    case OPENBRACKET:
      jj_consume_token(OPENBRACKET);
      s = ClauseOr();
      jj_consume_token(CLOSEBRACKET);
                        {if (true) return "(" + s + ")";}
      break;
    case K_ISINT:
    case K_ISFLOAT:
    case K_ISSTR:
    case K_ISBOOL:
    case IDNAME:
    case FIELDNAME:
    case TEXTVALUE:
    case FLOATVALUE:
    case INTVALUE:
      s = BoolExpression();
                        {if (true) return s;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String BoolExpression() throws ParseException {
                SimpleNode expr1 = null, expr2 = null;
                String op = null;
                int hint = 0;
    // First, an expression
                    expr1 = ExpressionRoot();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_LESS:
    case K_GREATER:
    case K_EQUAL:
    case K_NOTEQUAL:
    case K_RLIKE:
    case K_LIKE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_LESS:
        jj_consume_token(K_LESS);
                                           op = "<"; hint = HINT_NUMERIC;
        break;
      case K_GREATER:
        jj_consume_token(K_GREATER);
                                              op = ">"; hint = HINT_NUMERIC;
        break;
      case K_EQUAL:
        jj_consume_token(K_EQUAL);
                                            op = "=";
        break;
      case K_NOTEQUAL:
        jj_consume_token(K_NOTEQUAL);
                                               op = "=";
        break;
      case K_RLIKE:
        jj_consume_token(K_RLIKE);
                                            op = "RLIKE"; hint = HINT_STRING;
        break;
      case K_LIKE:
        jj_consume_token(K_LIKE);
                                           op = "LIKE"; hint = HINT_STRING;
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr2 = ExpressionRoot();
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
                        if ( expr2 == null )
                                {if (true) return parseExpression(expr1, HINT_BOOLEAN);}

                        else
                        {
                                // Attempt to mangle together a further hint, for example narrowing HINT_NUMERIC.
                                hint = getHint(expr1, expr2, hint);
                                {if (true) return parseExpression(expr1, hint) + " " + op + " " + parseExpression(expr2, hint);}
                        }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode ExpressionRoot() throws ParseException {
                                     /*@bgen(jjtree) Root */
  ObjectDBClauseNodeRoot jjtn000 = new ObjectDBClauseNodeRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExpressionAdd();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  final public void ExpressionAdd() throws ParseException {
                  ObjectDBClauseNodeAdd jjtn001 = new ObjectDBClauseNodeAdd(JJTADD);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
    try {
      ExpressionMul();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ADD:
        case K_SUBTRACT:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ADD:
          jj_consume_token(K_ADD);
          break;
        case K_SUBTRACT:
          jj_consume_token(K_SUBTRACT);
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        ExpressionMul();
      }
    } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
    } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
    }
  }

  final public void ExpressionMul() throws ParseException {
                  ObjectDBClauseNodeMul jjtn001 = new ObjectDBClauseNodeMul(JJTMUL);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
    try {
      Expression();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_MULTIPLY:
        case K_DIVIDE:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_MULTIPLY:
          jj_consume_token(K_MULTIPLY);
          break;
        case K_DIVIDE:
          jj_consume_token(K_DIVIDE);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
      }
    } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
    } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
    }
  }

  final public void Expression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENBRACKET:
      jj_consume_token(OPENBRACKET);
      ExpressionAdd();
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISINT:
      jj_consume_token(K_ISINT);
      jj_consume_token(OPENBRACKET);
      Field(HINT_INTEGER);
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISFLOAT:
      jj_consume_token(K_ISFLOAT);
      jj_consume_token(OPENBRACKET);
      Field(HINT_FLOAT);
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISSTR:
      jj_consume_token(K_ISSTR);
      jj_consume_token(OPENBRACKET);
      Field(HINT_STRING);
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISBOOL:
      jj_consume_token(K_ISBOOL);
      jj_consume_token(OPENBRACKET);
      Field(HINT_BOOLEAN);
      jj_consume_token(CLOSEBRACKET);
      break;
    case IDNAME:
    case FIELDNAME:
      Field(0);
      break;
    case TEXTVALUE:
    case FLOATVALUE:
    case INTVALUE:
      Constant();
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Constant() throws ParseException {
         /*@bgen(jjtree) Constant */
                ObjectDBClauseNodeConstant jjtn000 = new ObjectDBClauseNodeConstant(JJTCONSTANT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);Token value;
                int hint;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXTVALUE:
        value = jj_consume_token(TEXTVALUE);
                                hint = HINT_STRING;
        break;
      case FLOATVALUE:
        value = jj_consume_token(FLOATVALUE);
                                hint = HINT_FLOAT;
        break;
      case INTVALUE:
        value = jj_consume_token(INTVALUE);
                                hint = HINT_INTEGER;
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        jjtn000.setName(value.image);
                        jjtn000.setHint(hint);
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

  final public void Field(int hint) throws ParseException {
         /*@bgen(jjtree) Field */
                ObjectDBClauseNodeField jjtn000 = new ObjectDBClauseNodeField(JJTFIELD);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);Token name;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDNAME:
        name = jj_consume_token(IDNAME);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        jjtn000.setName(getFieldName(name.image));
                        jjtn000.setHint(HINT_ID);
        break;
      case FIELDNAME:
        name = jj_consume_token(FIELDNAME);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        jjtn000.setName(getFieldName(name.image));
                        jjtn000.setHint(hint);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

  final public void ParseSort() throws ParseException {
                Token t;
                String order = "ASC";
                boolean isInt = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ASC:
    case K_DESC:
    case K_INTEGER:
    case FIELDNAME:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ASC:
      case K_DESC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ASC:
          jj_consume_token(K_ASC);

          break;
        case K_DESC:
          jj_consume_token(K_DESC);
                                           order = "DESC";
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_INTEGER:
        jj_consume_token(K_INTEGER);
                                              isInt = true;
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      t = jj_consume_token(FIELDNAME);
                                String suffix = isInt ? ".FieldBigInt" : ".FieldStr";
                                sortOrder = " ORDER BY " + getFieldName(t.image) + suffix + " " + order;
      break;
    case K_RANDOM:
      jj_consume_token(K_RANDOM);
                                sortOrder = " ORDER BY RAND()";
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ParseLimit() throws ParseException {
                Token t1, t2;
    jj_consume_token(OPENBRACKET);
    t1 = jj_consume_token(INTVALUE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      t2 = jj_consume_token(INTVALUE);
      jj_consume_token(CLOSEBRACKET);
                                limitTo = " LIMIT " + t1.image + ", " + t2.image;
      break;
    case CLOSEBRACKET:
      jj_consume_token(CLOSEBRACKET);
                                limitTo = " LIMIT " + t1.image;
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ParseWith() throws ParseException {
                Token t1, t2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_AS:
      jj_consume_token(K_AS);
      t1 = jj_consume_token(FIELDNAME);
      t2 = jj_consume_token(FIELDNAME);
                                if (classMap.get(t1.image) == null)
                                {
                                        classMap.put(t1.image.toLowerCase(), classList.size());
                                        classList.add(t2.image);
                                }
      break;
    case FIELDNAME:
      t1 = jj_consume_token(FIELDNAME);
                                if (classMap.get(t1.image) == null)
                                {
                                        classMap.put(t1.image.toLowerCase(), classList.size());
                                        classList.add(t1.image);
                                }
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ParseSelect() throws ParseException {
                SimpleNode expr;
    expr = ExpressionRoot();
                                selClause = parseExpression(expr, HINT_INTEGER);
  }

  public ObjectDbClauseParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[20];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x1f00,0x1f00,0x20000,0x10000,0xa000,0x1f800000,0x1f800000,0x60000000,0x60000000,0x80000000,0x80000000,0x2000,0x0,0x0,0xc0000,0xc0000,0x100000,0x3c0000,0x4000,0x400000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x7fc,0x0,0x0,0x0,0x0,0x1,0x1,0x7fc,0x700,0xc0,0x0,0x0,0x0,0x80,0x2,0x80,};
   }

  public ObjectDbClauseParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ObjectDbClauseParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public ObjectDbClauseParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ObjectDbClauseParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public ObjectDbClauseParser(ObjectDbClauseParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(ObjectDbClauseParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[43];
    for (int i = 0; i < 43; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 20; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 43; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

        }
