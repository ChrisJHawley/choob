options {
	IGNORE_CASE = true;
	STATIC = false;
	OUTPUT_DIRECTORY = "org/uwcs/choob/support";
	NODE_DEFAULT_VOID = true;
	NODE_PREFIX = "ObjectDBClauseNode";
	MULTI = true;
}

PARSER_BEGIN(ObjectDbClauseParser)
	package org.uwcs.choob.support;
	import java.util.Map;
	import java.util.List;
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.Iterator;
	import java.io.StringReader;

	public class ObjectDbClauseParser {
		private int joins = 0;
		private List joinList = new ArrayList();
		private Map nameMap = new HashMap();
		private String sortOrder = "";
		private String limitTo = "";
		private String selClause = "s0.ClassID";
		private List classList = new ArrayList();
		private Map classMap = new HashMap();
		private Map fieldClass = new HashMap();

		// Negative values indicate nonspecific types.
		private static final int
			HINT_NUMERIC = -1,
			HINT_INTEGER = 1,
			HINT_FLOAT = 2,
			HINT_ID = 3,
			HINT_STRING = 4,
			HINT_BOOLEAN = 5;

		public static void main(String args[])
		{
			try
			{
				for(int i=0; i<args.length; i++)
				{
					System.out.println(getSQL(args[i], args[++i]));
				}
			}
			catch (ParseException e)
			{
				System.out.println("Parse exception: " + e);
				e.printStackTrace();
			}
		}

		public static String getSQL(String clause, String className) throws ParseException {
			if (className == null)
				throw new IllegalArgumentException("Null class name passed to getSQL...");

			ObjectDbClauseParser parser = new ObjectDbClauseParser (new StringReader(clause));

			parser.classList.add(className);
			parser.classMap.put(className.toLowerCase(), new Integer(0));

			StringBuffer whereClause = new StringBuffer("("+parser.SQL()+")");
			StringBuffer joinText = new StringBuffer();
			for (int i=0; i<parser.classList.size(); i++)
			{
				String classN = (String)parser.classList.get(i);
				joinText.append("ObjectStore s"+i);
				whereClause.append(" && s"+i+".ClassName = \"" + classN + "\"");
				if (i < parser.classList.size() - 1)
					joinText.append(" INNER JOIN ");
			}
			for(int i=0; i<parser.joinList.size(); i++)
			{
				joinText.append(" INNER JOIN ");
				String fullName = (String)parser.joinList.get(i);
				int pos = fullName.lastIndexOf('.');
				String fieldName = fullName.substring(pos + 1);
				joinText.append("ObjectStoreData o" + i + " ON s"+parser.fieldClass.get(fullName)+".ObjectID = o" + i + ".ObjectID AND o" + i + ".FieldName = \"" + fieldName + "\"");
			}
			return "SELECT " + parser.selClause + " FROM " + joinText.toString() + " WHERE " + whereClause.toString() + " GROUP BY s0.ClassID " + parser.sortOrder + parser.limitTo;
		}

		public String getFieldName(String name) throws ParseException
		{
			String fullName;
			if (name.lastIndexOf('.') == -1)
				fullName = (classList.get(0) + "." + name).toLowerCase();
			else
				fullName = name.toLowerCase();

			String realName = (String)nameMap.get(fullName);
			if (realName != null)
				return realName;

			// Need to add!
			int pos = fullName.lastIndexOf('.');
			String className = fullName.substring(0, pos);
			String fieldName = fullName.substring(pos + 1);

			Integer classID = (Integer)classMap.get(className);
			if (classID == null)
				throw new ParseException("Attempted to use a class not in a WITH clause...");

			if (fieldName.equals("id")) 
				// Special case, no join required...
				realName = "s"+classID+".ClassID";
			else
			{
				realName = "o"+joinList.size();
				joinList.add(fullName);
				fieldClass.put(fullName, classID);
			}

			nameMap.put(fullName, realName);
			return realName;
		}

		public String parseExpression(SimpleNode expr, int hint) throws ParseException
		{
			// Note that hint is now a solid hint: We can safely assume it as
			// the type for anything without an override.
			if (expr instanceof ObjectDBClauseNodeRoot)
			{
				StringBuffer buf = new StringBuffer();
				if(expr.jjtGetNumChildren() != 1)
					throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
				return parseExpression((SimpleNode)expr.jjtGetChild(0), hint);
			}
			else if (expr instanceof ObjectDBClauseNodeAdd)
			{
				StringBuffer buf = new StringBuffer();
				for(int i=0; i<expr.jjtGetNumChildren(); i++)
				{
					if (i != 0)
						buf.append(" + ");
					buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
				}
				return buf.toString();
			}
			else if (expr instanceof ObjectDBClauseNodeMul)
			{
				StringBuffer buf = new StringBuffer();
				for(int i=0; i<expr.jjtGetNumChildren(); i++)
				{
					if (i != 0)
						buf.append(" * ");
					buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
				}
				return buf.toString();
			}
			else if (expr instanceof ObjectDBClauseNodeConstant)
			{
				return expr.getName();
			}
			else if (expr instanceof ObjectDBClauseNodeField)
			{
				// The only really tricky one...
				int thingHint = expr.getHint() != 0 ? expr.getHint() : hint;
				String prefix = expr.getName();
				if (thingHint == HINT_INTEGER)
					return prefix + ".FieldBigInt";
				else if (thingHint == HINT_FLOAT)
					return prefix + ".FieldDouble";
				else if (thingHint == HINT_BOOLEAN)
					return prefix + ".FieldBigInt"; // 1 for true, so all good
				else if (thingHint == HINT_STRING)
					return prefix + ".FieldString";
				else if (thingHint == HINT_ID)
					return prefix; // Special case; id fields are stored as the full name anyway.
			}
			throw new ParseException("Could not parse node of type " + expr.getClass().getSimpleName() + " with hint " + hint + " into column name.");
		}

		public int getHint(SimpleNode expr1, SimpleNode expr2, int hint) throws ParseException
		{
			// Try to get  hint from expr2, if that fails use expr1.
			return getHint(expr1, getHint(expr2, hint, true), false);
		}

		public int getHint(SimpleNode expr, int hint, boolean noResolve) throws ParseException
		{
			// If the hint is already "solid", just return.
			if (hint > 0)
				return hint;

			if (expr instanceof ObjectDBClauseNodeRoot)
			{
				StringBuffer buf = new StringBuffer();
				if(expr.jjtGetNumChildren() != 1)
					throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
				hint = getHint((SimpleNode)expr.jjtGetChild(0), hint, noResolve);
			}
			else if (expr instanceof ObjectDBClauseNodeAdd)
			{
				if(expr.jjtGetNumChildren() > 1)
					hint = HINT_NUMERIC; // We used maths!

				for(int i=0; i<expr.jjtGetNumChildren(); i++)
					hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
			}
			else if (expr instanceof ObjectDBClauseNodeMul)
			{
				if(expr.jjtGetNumChildren() > 1)
					hint = HINT_NUMERIC; // We used maths!

				for(int i=0; i<expr.jjtGetNumChildren(); i++)
					hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
			}
			else if (expr instanceof ObjectDBClauseNodeConstant)
			{
				hint = expr.getHint();
			}
			else if (expr instanceof ObjectDBClauseNodeField)
			{
				// The only really tricky one...
				int newHint = expr.getHint();
				if (newHint < 0 && hint == 0)
					hint = expr.getHint();
				else if (newHint > 0)
					if (newHint != HINT_ID)
						hint = expr.getHint();
					else
						hint = HINT_INTEGER;
			}

			// If we haven't finished processing, just return current hint.
			if (noResolve || hint > 0)
				return hint;

			// Otherwise, make the most "general" solid hint we can.
			if (hint == HINT_NUMERIC)
				return HINT_FLOAT;
			else
				return HINT_STRING;
		}
	}
PARSER_END(ObjectDbClauseParser)

<*>
SKIP: { " " | "\n" | "\t" }

// Definitions
TOKEN: {
	<#P_FLOATVALUE: ("-")? ( ["0"-"9"] ) + "." ( ["0"-"9"] ) +>
|	<#P_INTVALUE: ("-")? ( ["0"-"9"] ) + >
|	<#P_TEXTVALUE: "\"" ( ~ ["\"", "\\"] | "\\" ~[] ) * "\"" | "'" ( ~ ["'", "\\"] | "\\" ~[] ) * "'">
|	<#P_NAME: ["a"-"z"] ( ["a"-"z", "0"-"9", "_"] )* >
}

// Things

TOKEN: {
	<K_WHERE: "WHERE">
|	<K_SORT: "SORT" ( " BY" )?>
|	<K_LIMIT: "LIMIT">
|	<K_WITH: "WITH">
|	<K_SELECT: "SELECT">

|	<OPENBRACKET: "(">
|	<CLOSEBRACKET: ")">

|	<K_NOT: "!" | "NOT">
|	<K_AND: "AND" | "&&">
|	<K_OR: "OR" | "||">

|	<K_ASC: "ASC" | "ASCENDING">
|	<K_DESC: "DESC" | "DESCENDING">
|	<K_INTEGER: "INTEGER">
|	<K_RANDOM: "RANDOM" | "RAND">

|	<K_AS: "AS">

|	<K_LESS: "<">
|	<K_GREATER: ">">
|	<K_EQUAL: "=">
|	<K_NOTEQUAL: "!=">
|	<K_RLIKE: "RLIKE" | "REGEXP" | "~">
|	<K_LIKE: "LIKE">

|	<K_ADD: "+">
|	<K_SUBTRACT: "-">
|	<K_MULTIPLY: "*">
|	<K_DIVIDE: "/">

|	<COMMA: ",">

|	<K_ISINT: "ISINT">
|	<K_ISFLOAT: "ISFLOAT">
|	<K_ISSTR: "ISSTR" | "ISSTRING">
|	<K_ISBOOL: "ISBOOL">

|	<IDNAME: (<P_NAME> ("." <P_NAME>)* ".")? "id">
|	<FIELDNAME: <P_NAME> ("." <P_NAME>)* >
|	<TEXTVALUE: <P_TEXTVALUE>>
|	<FLOATVALUE: <P_FLOATVALUE>>
|	<INTVALUE: <P_INTVALUE>>
}

String SQL () :
	{
		String s;
		StringBuffer b = new StringBuffer();
		boolean clause = false;
	}
	{
		(
			<K_WITH> ParseWith()
			{ }
		|
			<K_SORT> ParseSort()
			{ }
		|
			<K_LIMIT> ParseLimit()
			{ }
		|
			<K_SELECT> ParseSelect()
			{ }
		|
			<K_WHERE> s = ClauseOr()
			{
				clause = true;
				b.append(s);
			}
		)*
		{ return clause ? b.toString() : "1"; }
	}

String ClauseOr () :
	{
		StringBuffer out = new StringBuffer();
		String clause;
	}
	{
// If we wanted trees here:
//		(
//			ClauseAnd() ( <K_OR> t = ClauseAnd() ) *
//		) #Or(>1)
		clause = ClauseAnd() { out.append(clause); }
		( <K_OR> clause = ClauseAnd() { out.append(" OR " + clause); } ) *
		{
			return out.toString();
		}
	}

String ClauseAnd () :
	{
		StringBuffer out = new StringBuffer();
		String clause;
	}
	{
// If we wanted trees here:
//		(
//			Clause() ( <K_AND> t = Clause() ) *
//		) #And(>1)
		clause = Clause() { out.append(clause); }
		( <K_AND> clause = Clause() { out.append(" AND " + clause); } ) *
		{
			return out.toString();
		}
	}

String Clause() :
	{
		java.util.Vector list;
		String s;
	}
	{
		<K_NOT> s = Clause()
		{
			return "NOT " + s;
		}
	|
		<OPENBRACKET> s = ClauseOr() <CLOSEBRACKET>
		{
			return "(" + s + ")";
		}
	|
		s = BoolExpression()
		{
			return s;
		}
	}

String BoolExpression() :
	{
		SimpleNode expr1 = null, expr2 = null;
		String op = null;
		int hint = 0;
	}
	{
		// First, an expression
		expr1 = ExpressionRoot()

		(
			// Operator
			(
				<K_LESS> { op = "<"; hint = HINT_NUMERIC; }
			|
				<K_GREATER> { op = ">"; hint = HINT_NUMERIC; }
			|
				<K_EQUAL> { op = "="; }
			|
				<K_NOTEQUAL> { op = "="; }
			|
				<K_RLIKE> { op = "RLIKE"; hint = HINT_STRING; }
			|
				<K_LIKE> { op = "LIKE"; hint = HINT_STRING; }
			)
			expr2 = ExpressionRoot()
		)?
		{
			if ( expr2 == null )
				return parseExpression(expr1, HINT_BOOLEAN);

			else
			{
				// Attempt to mangle together a further hint, for example narrowing HINT_NUMERIC.
				hint = getHint(expr1, expr2, hint);
				return parseExpression(expr1, hint) + " " + op + " " + parseExpression(expr2, hint);
			}
		}
	}

SimpleNode ExpressionRoot() #Root : { }
	{
		ExpressionAdd()
		{
			return jjtThis;
		}
	}

void ExpressionAdd() :
	{ }
	{
		(
			ExpressionMul()
			(
				( <K_ADD> | <K_SUBTRACT> ) ExpressionMul()
			) *
		) #Add(>1)
	}

void ExpressionMul() : { }
	{
		(
			Expression()
			(
				( <K_MULTIPLY> | <K_DIVIDE> ) Expression()
			) *
		) #Mul(>1)
	}

void Expression() : { }
	{
		( <OPENBRACKET> ExpressionAdd() <CLOSEBRACKET> )
	|
		<K_ISINT> <OPENBRACKET> Field(HINT_INTEGER) <CLOSEBRACKET>
	|
		<K_ISFLOAT> <OPENBRACKET> Field(HINT_FLOAT) <CLOSEBRACKET>
	|
		<K_ISSTR> <OPENBRACKET> Field(HINT_STRING) <CLOSEBRACKET>
	|
		<K_ISBOOL> <OPENBRACKET> Field(HINT_BOOLEAN) <CLOSEBRACKET>
	|
		Field(0)
	|
		Constant()
	}

void Constant() #Constant :
	{
		Token value;
		int hint;
	}
	{
		(
			value = <TEXTVALUE>
			{
				hint = HINT_STRING;
			}
		|
			value = <FLOATVALUE>
			{
				hint = HINT_FLOAT;
			}
		|
			value = <INTVALUE>
			{
				hint = HINT_INTEGER;
			}
		)
		{
			jjtThis.setName(value.image);
			jjtThis.setHint(hint);
		}
	}

void Field(int hint) #Field :
	{
		Token name;
	}
	{
		name = <IDNAME>
		{
			jjtThis.setName(getFieldName(name.image));
			jjtThis.setHint(HINT_ID);
		}
	|
		name = <FIELDNAME>
		{
			jjtThis.setName(getFieldName(name.image));
			jjtThis.setHint(hint);
		}
	}

void ParseSort() :
	{
		Token t;
		String order = "ASC";
		boolean isInt = false;
	}
	{
		(
			(
				<K_ASC> { }
			|
				<K_DESC> { order = "DESC"; }
			)?
			(
				<K_INTEGER> { isInt = true; }
			)?
			t = <FIELDNAME>
			{
				String suffix = isInt ? ".FieldBigInt" : ".FieldStr";
				sortOrder = " ORDER BY " + getFieldName(t.image) + suffix + " " + order;
			}
		|
			<K_RANDOM>
			{
				sortOrder = " ORDER BY RAND()";
			}
		)
	}

void ParseLimit() :
	{
		Token t1, t2;
	}
	{
		<OPENBRACKET> t1 = <INTVALUE>
		(
			<COMMA> t2 = <INTVALUE> <CLOSEBRACKET>
			{
				limitTo = " LIMIT " + t1.image + ", " + t2.image;
			}
		|
			<CLOSEBRACKET>
			{
				limitTo = " LIMIT " + t1.image;
			}
		)
	}

void ParseWith() :
	{
		Token t1, t2;
	}
	{
		(
			<K_AS> t1 = <FIELDNAME> t2 = <FIELDNAME>
			{
				if (classMap.get(t1.image) == null)
				{
					classMap.put(t1.image.toLowerCase(), classList.size());
					classList.add(t2.image);
				}
			}
		|
			t1 = <FIELDNAME> {
				if (classMap.get(t1.image) == null)
				{
					classMap.put(t1.image.toLowerCase(), classList.size());
					classList.add(t1.image);
				}
			}
		)
	}

void ParseSelect() :
	{
		Token t;
	}
	{
		(
//			<K_COUNT>
//			{
//				selClause = "COUNT(s0.ClassID)";
//			}
//		|
//			<K_SUM> t = <FIELDNAME>
//			{
//				selClause = "SUM("+getFieldName(t.image)+")";
//			}
//		|
			t = <FIELDNAME>
			{
				selClause = getFieldName(t.image);
			}
		)
	}

