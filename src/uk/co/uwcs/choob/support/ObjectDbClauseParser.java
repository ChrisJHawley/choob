/* Generated By:JJTree&JavaCC: Do not edit this line. ObjectDbClauseParser.java */
        package uk.co.uwcs.choob.support;
        import java.util.Map;
        import java.util.List;
        import java.util.ArrayList;
        import java.util.HashMap;
        import java.util.Iterator;
        import java.io.StringReader;

        public class ObjectDbClauseParser/*@bgen(jjtree)*/implements ObjectDbClauseParserTreeConstants, ObjectDbClauseParserConstants {/*@bgen(jjtree)*/
  protected JJTObjectDbClauseParserState jjtree = new JJTObjectDbClauseParserState();private int joins = 0;
                private List joinList = new ArrayList();  // List of properties to join on.
                private Map nameMap = new HashMap();      // List of indices into joinList for join names.
                private List classList = new ArrayList(); // List of classes used.
                private Map classMap = new HashMap();     // Map of alias name -> classList offset.
                private Map fieldClass = new HashMap();   // Map of field name -> classList offset.
                private List modifiedClasses = new ArrayList(); // List of classes modified.
                private String joinWhere = null;

                // Negative values indicate nonspecific types.
                public final static int
                        HINT_NUMERIC = -1,
                        HINT_UNKNOWN = 0,
                        HINT_INTEGER = 1,
                        HINT_FLOAT = 2,
                        HINT_ID = 3,
                        HINT_STRING = 4,
                        HINT_BOOLEAN = 5;

                private int type = TYPE_UNKNOWN;

                public final static int
                        TYPE_UNKNOWN = 0,
                        TYPE_SELECT = 1,
                        TYPE_UPDATE = 2,
                        TYPE_DELETE = 3,
                        TYPE_INSERT = 4;

                public ObjectDbClauseParser(String clause, String className)
                {
                        this(new StringReader(clause));
                        classList.add(className);
                        classMap.put(className.toLowerCase(), new Integer(0));
                }

                public ObjectDbClauseParser(String clause)
                {
                        this(new StringReader(clause));
                }

                public static void main(String args[])
                {
                        try
                        {
                                for(int i=0; i<args.length; i++)
                                {
                                        System.out.println(getSQL(args[i]));
                                }
                        }
                        catch (ParseException e)
                        {
                                System.out.println("Parse exception: " + e);
                                e.printStackTrace();
                        }
                }

                public static String getSQL(String clause, String className) throws ParseException
                {
                        if (className == null)
                                throw new IllegalArgumentException("Null class name passed to getSQL...");

                        ObjectDbClauseParser parser = new ObjectDbClauseParser (clause, className);

                        return parser.ODBExpr();
                }

                public static String getSQL(String clause) throws ParseException
                {
                        ObjectDbClauseParser parser = new ObjectDbClauseParser (clause);

                        return parser.ODBExpr();
                }

                /**
		 * Gets the type of this query (TYPE_SELECT, ...)
		 */
                public int getType()
                {
                        return type;
                }

                /**
		 * For a modification statement, returns the classes which may be altered.
		 */
                public List getModifiedClasses()
                {
                        return modifiedClasses;
                }

                /**
		 * Returns the classes which may be read from.
		 */
                public List getUsedClasses()
                {
                        return classList;
                }

                public String getTableJoin()
                {
                        StringBuffer joinText = new StringBuffer();
                        StringBuffer whereText = new StringBuffer("(1");
                        for (int i=0; i<classList.size(); i++)
                        {
                                String classN = (String)classList.get(i);
                                joinText.append("ObjectStore s"+i);
                                whereText.append(" AND s"+i+".ClassName = \"" + classN + "\"");
                                if (i < classList.size() - 1)
                                        joinText.append(" INNER JOIN ");
                        }
                        for (int i=0; i<joinList.size(); i++)
                        {
                                joinText.append(" INNER JOIN ");
                                String fullName = (String)joinList.get(i);
                                int pos = fullName.lastIndexOf('.');
                                String fieldName = fullName.substring(pos + 1);
                                joinText.append("ObjectStoreData o" + i + " ON s"+fieldClass.get(fullName)+".ObjectID = o" + i + ".ObjectID AND o" + i + ".FieldName = \"" + fieldName + "\"");
                        }
                        whereText.append(")");
                        joinWhere = whereText.toString();
                        return joinText.toString();
                }

                public String getFieldName(String name) throws ParseException
                {
                        String fullName;
                        if (name.lastIndexOf('.') == -1)
                                fullName = (classList.get(0) + "." + name).toLowerCase();
                        else
                                fullName = name.toLowerCase();

                        String realName = (String)nameMap.get(fullName);
                        if (realName != null)
                                return realName;

                        // Need to add!
                        int pos = fullName.lastIndexOf('.');
                        String className = fullName.substring(0, pos);
                        String fieldName = fullName.substring(pos + 1);

                        Integer classID = (Integer)classMap.get(className);
                        if (classID == null)
                                throw new ParseException("Attempted to use a class not in a WITH clause...");

                        if (fieldName.equals("id"))
                                // Special case, no join required...
                                realName = "s"+classID+".ClassID";
                        else
                        {
                                realName = "o"+joinList.size();
                                joinList.add(fullName);
                                fieldClass.put(fullName, classID);
                        }

                        nameMap.put(fullName, realName);
                        return realName;
                }

                public String parseExpression(SimpleNode expr, int hint) throws ParseException
                {
                        // Note that hint is now a solid hint: We can safely assume it as
                        // the type for anything without an override.
                        if (expr instanceof ObjectDBClauseNodeRoot)
                        {
                                StringBuffer buf = new StringBuffer();
                                if(expr.jjtGetNumChildren() != 1)
                                        throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
                                return parseExpression((SimpleNode)expr.jjtGetChild(0), hint);
                        }
                        else if (expr instanceof ObjectDBClauseNodeExpressionList)
                        {
                                StringBuffer buf = new StringBuffer();
                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                {
                                        if (i != 0)
                                                buf.append(", ");
                                        buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
                                }
                                return buf.toString();
                        }
                        else if (expr instanceof ObjectDBClauseNodeFunction)
                        {
                                StringBuffer buf = new StringBuffer(expr.getName()+"(");
                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                {
                                        if (i != 0)
                                                buf.append(", ");
                                        buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
                                }
                                buf.append(")");
                                return buf.toString();
                        }
                        else if (expr instanceof ObjectDBClauseNodeAdd)
                        {
                                StringBuffer buf = new StringBuffer();
                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                {
                                        if (i != 0)
                                                buf.append(" + ");
                                        buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
                                }
                                return buf.toString();
                        }
                        else if (expr instanceof ObjectDBClauseNodeMul)
                        {
                                StringBuffer buf = new StringBuffer();
                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                {
                                        if (i != 0)
                                                buf.append(" * ");
                                        buf.append(parseExpression((SimpleNode)expr.jjtGetChild(i), hint));
                                }
                                return buf.toString();
                        }
                        else if (expr instanceof ObjectDBClauseNodeConstant)
                        {
                                return expr.getName();
                        }
                        else if (expr instanceof ObjectDBClauseNodeField)
                        {
                                // The only really tricky one...
                                int thingHint = expr.getHint() != 0 ? expr.getHint() : hint;
                                if (thingHint == 0)
                                        thingHint = HINT_STRING;
                                String prefix = getFieldName(expr.getName());
                                if (thingHint == HINT_INTEGER)
                                        return prefix + ".FieldBigInt";
                                else if (thingHint == HINT_FLOAT)
                                        return prefix + ".FieldDouble";
                                else if (thingHint == HINT_BOOLEAN)
                                        return prefix + ".FieldBigInt"; // 1 for true, so all good
                                else if (thingHint == HINT_STRING)
                                        return prefix + ".FieldString";
                                else if (thingHint == HINT_ID)
                                        return prefix; // Special case; id fields are stored as the full name anyway.
                        }
                        throw new ParseException("Could not parse node of type " + expr.getClass().getSimpleName() + " with hint " + hint + " into column name.");
                }

                public int getHint(SimpleNode expr1, SimpleNode expr2, int hint) throws ParseException
                {
                        // Try to get  hint from expr2, if that fails use expr1.
                        return getHint(expr1, getHint(expr2, hint, true), false);
                }

                public int getHint(SimpleNode expr, int hint, boolean noResolve) throws ParseException
                {
                        // If the hint is already "solid", just return.
                        if (hint > 0)
                                return hint;

                        if (expr instanceof ObjectDBClauseNodeRoot)
                        {
                                StringBuffer buf = new StringBuffer();
                                if(expr.jjtGetNumChildren() != 1)
                                        throw new ParseException("Root node has a number of children other than 1. This should be impossible!");
                                hint = getHint((SimpleNode)expr.jjtGetChild(0), hint, noResolve);
                        }
                        else if (expr instanceof ObjectDBClauseNodeAdd)
                        {
                                if(expr.jjtGetNumChildren() > 1)
                                        hint = HINT_NUMERIC; // We used maths!

                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                        hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
                        }
                        else if (expr instanceof ObjectDBClauseNodeMul)
                        {
                                if(expr.jjtGetNumChildren() > 1)
                                        hint = HINT_NUMERIC; // We used maths!

                                for(int i=0; i<expr.jjtGetNumChildren(); i++)
                                        hint = getHint((SimpleNode)expr.jjtGetChild(i), hint, true);
                        }
                        else if (expr instanceof ObjectDBClauseNodeConstant)
                        {
                                hint = expr.getHint();
                        }
                        else if (expr instanceof ObjectDBClauseNodeField)
                        {
                                // The only really tricky one...
                                int newHint = expr.getHint();
                                if (newHint < 0 && hint == 0)
                                        hint = expr.getHint();
                                else if (newHint > 0)
                                        if (newHint != HINT_ID)
                                                hint = expr.getHint();
                                        else
                                                hint = HINT_INTEGER;
                        }

                        // If we haven't finished processing, just return current hint.
                        if (noResolve || hint > 0)
                                return hint;

                        // Otherwise, make the most "general" solid hint we can.
                        if (hint == HINT_NUMERIC)
                                return HINT_FLOAT;
                        else
                                return HINT_STRING;
                }

                public String join(List list)
                {
                        if (list.size() == 0)
                                return "";
                        StringBuffer buf = new StringBuffer();
                        boolean first = true;
                        Iterator it = list.iterator();
                        while(it.hasNext())
                        {
                                if (first)
                                        first = false;
                                else
                                        buf.append(", ");
                                buf.append((String)it.next());
                        }
                        return buf.toString();
                }

  final public String ODBExpr() throws ParseException {
                String s = null, t;
                StringBuffer b = new StringBuffer();
                SimpleNode l;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_SELECT:
      jj_consume_token(K_SELECT);
      l = ExpressionList();
      t = ParseSelect(l);
                          {if (true) return t;}
      break;
    case K_INSERT:
      jj_consume_token(K_INSERT);
      t = ParseInsert();
                          {if (true) return t;}
      break;
    case K_UPDATE:
      jj_consume_token(K_UPDATE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_TABLE:
        jj_consume_token(K_TABLE);
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FIELDNAME:
        s = ClassName();
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
                                if (s == null)
                                {
                                        if (classList.size() > 0)
                                                s = (String)classList.get(0);
                                        else
                                                {if (true) throw new ParseException("No class specified for classless UPDATE");}
                                }
      t = ParseUpdate(s);
                          {if (true) return t;}
      break;
    case K_DELETE:
      jj_consume_token(K_DELETE);
      t = ParseDelete();
                          {if (true) return t;}
      break;
    default:
      jj_la1[2] = jj_gen;
      t = ParseSelect(null);
                          {if (true) return t;}
    }
    throw new Error("Missing return statement in function");
  }

  final public String ParseSelect(SimpleNode cols) throws ParseException {
                String cls = null;
                if (classList.size() > 0)
                        cls = (String)classList.get(0);

                String sort = "";
                String limit = "";
                String where = "1";

                String string;
                List stringList;
                SimpleNode l;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_WHERE:
      case K_SORT:
      case K_LIMIT:
      case K_WITH:
      case K_FROM:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_WITH:
        jj_consume_token(K_WITH);
        string = ClassName();
                                if (cls == null)
                                        {if (true) throw new ParseException("WITH clause used on a query which had no FROM class.");}
                                else
                                        cls = string;
        break;
      case K_FROM:
        jj_consume_token(K_FROM);
        stringList = ClassList();
                                if (cls == null)
                                        cls = (String)stringList.get(0);
                                else
                                        {if (true) throw new ParseException("FROM clause used on a query which already had a FROM class.");}
        break;
      case K_SORT:
        jj_consume_token(K_SORT);
        string = ParseSort();
                                if (sort.equals(""))
                                        sort = " " + string;
                                else
                                        {if (true) throw new ParseException("Multiple SORT clauses.");}
        break;
      case K_LIMIT:
        jj_consume_token(K_LIMIT);
        string = ParseLimit();
                                if (limit.equals(""))
                                        limit = " " + string;
                                else
                                        {if (true) throw new ParseException("Multiple LIMIT clauses.");}
        break;
      case K_WHERE:
        jj_consume_token(K_WHERE);
        string = ClauseOr();
                                if (where.equals("1"))
                                        where = string;
                                else
                                        {if (true) throw new ParseException("Multiple WHERE clauses.");}
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                        if (cls == null)
                                {if (true) throw new ParseException("No FROM clause in SELECT statement.");}

                        type = TYPE_SELECT;

                        String realCols = (cols == null ? "s0.ClassID" : parseExpression(cols, HINT_UNKNOWN));
                        String tableJoin = getTableJoin(); // Also updates joinWhere.
                        {if (true) return "SELECT " + realCols + " FROM " + tableJoin + " WHERE " + where + " AND " + joinWhere + " GROUP BY s0.ClassID" + sort + limit;}
    throw new Error("Missing return statement in function");
  }

  final public String ParseUpdate(String cls) throws ParseException {
                SimpleNode cols;
                String where = "1";
    jj_consume_token(K_SET);
    cols = FieldSetList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_WHERE:
      jj_consume_token(K_WHERE);
      where = ClauseOr();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
                        modifiedClasses.add(cls);
                        type = TYPE_UPDATE;

                        StringBuffer update = new StringBuffer();
                        StringBuffer inserts = new StringBuffer();
                        for(int i=0; i<cols.jjtGetNumChildren(); i++)
                        {
                                SimpleNode col = (SimpleNode)cols.jjtGetChild(i);
                                if (i != 0)
                                        update.append(", ");
                                String name = getFieldName(col.getName());
                                inserts.append("INSERT IGNORE INTO ObjectStoreData SELECT ObjectID, \"" + col.getName() + "\", NULL, NULL, NULL FROM ObjectStore WHERE ClassName = \"" + cls + "\";\n");

                                // Parse once for strings
                                int hint = getHint((SimpleNode)col.jjtGetChild(0), HINT_UNKNOWN, false);
                                String result = parseExpression((SimpleNode)col.jjtGetChild(0), hint);
                                update.append(name + ".FieldString = " + result + ", ");

                                // And again for numerics
                                hint = getHint((SimpleNode)col.jjtGetChild(0), HINT_NUMERIC, false);
                                result = parseExpression((SimpleNode)col.jjtGetChild(0), hint);
                                update.append(name + ".FieldBigInt = " + result + ", ");
                                update.append(name + ".FieldDouble = " + result);
                        }
                        String tableJoin = getTableJoin(); // Also updates joinWhere.
                        update.append(" WHERE " + where + " AND " + joinWhere);
                        inserts.append("UPDATE " + tableJoin + " SET " + update.toString());
                        {if (true) return inserts.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String ParseInsert() throws ParseException {
                String cls = null;
                if (classList.size() > 0)
                        cls = (String)classList.get(0);

                String fields, string;
                SimpleNode cols;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_INTO:
      jj_consume_token(K_INTO);
      string = ClassName();
                                if (cls != null)
                                        cls = string;
                                else
                                        {if (true) throw new ParseException("INTO clause used on a query which already had an INTO class.");}
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(K_SET);
    cols = FieldSetList();
                        modifiedClasses.add(cls);
                        type = TYPE_INSERT;

                        String idClause = "DEFAULT";
                        // Find an ID clause, if any...
                        for(int i=0; i<cols.jjtGetNumChildren(); i++)
                        {
                                SimpleNode col = (SimpleNode)cols.jjtGetChild(i);
                                if (col.getName().equalsIgnoreCase("id"))
                                        idClause = parseExpression((SimpleNode)col.jjtGetChild(0), HINT_UNKNOWN);
                        }

                        StringBuffer query = new StringBuffer("INSERT INTO ObjectStore VALUES(" + idClause + ", '" + cls + "', id);\n");
                        for(int i=0; i<cols.jjtGetNumChildren(); i++)
                        {
                                SimpleNode col = (SimpleNode)cols.jjtGetChild(i);

                                if (col.getName().equalsIgnoreCase("id"))
                                        continue;

                                String value = parseExpression((SimpleNode)col.jjtGetChild(0), HINT_UNKNOWN);
                                query.append("INSERT INTO ObjectStoreData VALUES(LAST_INSERT_ID(), \"" + col.getName() + "\", " + value + ", " + value + ", " + value + ");\n");
                        }
                        {if (true) return query.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String ParseDelete() throws ParseException {
                String cls = null;
                if (classList.size() > 0)
                        cls = (String)classList.get(0);

                String where = "1";
                String string;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_FROM:
      jj_consume_token(K_FROM);
      string = ClassName();
                                if (cls != null)
                                        cls = string;
                                else
                                        {if (true) throw new ParseException("FROM clause used on a query which already had a FROM class.");}
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_WHERE:
      jj_consume_token(K_WHERE);
      string = ClauseOr();
                                where = string;
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
                        if (cls == null)
                                {if (true) throw new ParseException("No FROM clause in a DELETE.");}

                        modifiedClasses.add(cls);
                        type = TYPE_DELETE;

                        String tableJoin = getTableJoin(); // Also updates joinWhere.
                        {if (true) return "DELETE FROM s0 USING " + tableJoin + " WHERE " + where + " AND " + joinWhere;}
    throw new Error("Missing return statement in function");
  }

/**
 * WHERE parser
 */
  final public String ClauseOr() throws ParseException {
                StringBuffer out = new StringBuffer();
                String clause;
    // If we wanted trees here:
    //		(
    //			ClauseAnd() ( <K_OR> t = ClauseAnd() ) *
    //		) #Or(>1)
                    clause = ClauseAnd();
                                       out.append(clause);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_OR:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_2;
      }
      jj_consume_token(K_OR);
      clause = ClauseAnd();
                                                out.append(" OR " + clause);
    }
                        {if (true) return out.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String ClauseAnd() throws ParseException {
                StringBuffer out = new StringBuffer();
                String clause;
    // If we wanted trees here:
    //		(
    //			Clause() ( <K_AND> t = Clause() ) *
    //		) #And(>1)
                    clause = Clause();
                                    out.append(clause);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_AND:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_3;
      }
      jj_consume_token(K_AND);
      clause = Clause();
                                              out.append(" AND " + clause);
    }
                        {if (true) return out.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String Clause() throws ParseException {
                java.util.Vector list;
                String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOT:
      jj_consume_token(K_NOT);
      s = Clause();
                        {if (true) return "NOT " + s;}
      break;
    case OPENBRACKET:
      jj_consume_token(OPENBRACKET);
      s = ClauseOr();
      jj_consume_token(CLOSEBRACKET);
                        {if (true) return "(" + s + ")";}
      break;
    case K_0FUNC:
    case K_1FUNC:
    case K_2FUNC:
    case K_3FUNC:
    case K_ISINT:
    case K_ISFLOAT:
    case K_ISSTR:
    case K_ISBOOL:
    case IDNAME:
    case FIELDNAME:
    case TEXTVALUE:
    case FLOATVALUE:
    case INTVALUE:
      s = BoolExpression();
                        {if (true) return s;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String BoolExpression() throws ParseException {
                SimpleNode expr1, expr2 = null;
                String op = null;
                int hint = 0;
    // First, an expression
                    expr1 = ExpressionRoot();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_LESS:
    case K_GREATER:
    case K_EQUAL:
    case K_NOTEQUAL:
    case K_RLIKE:
    case K_LIKE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_LESS:
        jj_consume_token(K_LESS);
                                           op = "<"; hint = HINT_NUMERIC;
        break;
      case K_GREATER:
        jj_consume_token(K_GREATER);
                                              op = ">"; hint = HINT_NUMERIC;
        break;
      case K_EQUAL:
        jj_consume_token(K_EQUAL);
                                            op = "=";
        break;
      case K_NOTEQUAL:
        jj_consume_token(K_NOTEQUAL);
                                               op = "=";
        break;
      case K_RLIKE:
        jj_consume_token(K_RLIKE);
                                            op = "RLIKE"; hint = HINT_STRING;
        break;
      case K_LIKE:
        jj_consume_token(K_LIKE);
                                           op = "LIKE"; hint = HINT_STRING;
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr2 = ExpressionRoot();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
                        if ( expr2 == null )
                                {if (true) return parseExpression(expr1, HINT_BOOLEAN);}

                        else
                        {
                                // Attempt to mangle together a further hint, for example narrowing HINT_NUMERIC.
                                hint = getHint(expr1, expr2, hint);
                                {if (true) return parseExpression(expr1, hint) + " " + op + " " + parseExpression(expr2, hint);}
                        }
    throw new Error("Missing return statement in function");
  }

  final public String Expression(int hint) throws ParseException {
                SimpleNode root;
    root = ExpressionRoot();
                        {if (true) return parseExpression(root, hint);}
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode ExpressionRoot() throws ParseException {
                                     /*@bgen(jjtree) Root */
  ObjectDBClauseNodeRoot jjtn000 = new ObjectDBClauseNodeRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExpressionAdd();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  final public void ExpressionAdd() throws ParseException {
                  ObjectDBClauseNodeAdd jjtn001 = new ObjectDBClauseNodeAdd(JJTADD);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
    try {
      ExpressionMul();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ADD:
        case K_SUBTRACT:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_4;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ADD:
          jj_consume_token(K_ADD);
          break;
        case K_SUBTRACT:
          jj_consume_token(K_SUBTRACT);
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        ExpressionMul();
      }
    } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
    } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
    }
  }

  final public void ExpressionMul() throws ParseException {
                  ObjectDBClauseNodeMul jjtn001 = new ObjectDBClauseNodeMul(JJTMUL);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
    try {
      ExpressionUnit();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_MULTIPLY:
        case K_DIVIDE:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_MULTIPLY:
          jj_consume_token(K_MULTIPLY);
          break;
        case K_DIVIDE:
          jj_consume_token(K_DIVIDE);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        ExpressionUnit();
      }
    } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
    } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                  }
    }
  }

  final public void ExpressionUnit() throws ParseException {
                          Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENBRACKET:
      jj_consume_token(OPENBRACKET);
      ExpressionAdd();
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISINT:
      jj_consume_token(K_ISINT);
      jj_consume_token(OPENBRACKET);
      Field(HINT_INTEGER);
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISFLOAT:
      jj_consume_token(K_ISFLOAT);
      jj_consume_token(OPENBRACKET);
      Field(HINT_FLOAT);
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISSTR:
      jj_consume_token(K_ISSTR);
      jj_consume_token(OPENBRACKET);
      Field(HINT_STRING);
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_ISBOOL:
      jj_consume_token(K_ISBOOL);
      jj_consume_token(OPENBRACKET);
      Field(HINT_BOOLEAN);
      jj_consume_token(CLOSEBRACKET);
      break;
    case K_0FUNC:
      t = jj_consume_token(K_0FUNC);
      Function(t.image, 0);
      break;
    case K_1FUNC:
      t = jj_consume_token(K_1FUNC);
      Function(t.image, 1);
      break;
    case K_2FUNC:
      t = jj_consume_token(K_2FUNC);
      Function(t.image, 2);
      break;
    case K_3FUNC:
      t = jj_consume_token(K_3FUNC);
      Function(t.image, 3);
      break;
    case IDNAME:
    case FIELDNAME:
      Field(0);
      break;
    case TEXTVALUE:
    case FLOATVALUE:
    case INTVALUE:
      Constant();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Function(String name, int params) throws ParseException {
                                                    /*@bgen(jjtree) Function */
                                                     ObjectDBClauseNodeFunction jjtn000 = new ObjectDBClauseNodeFunction(JJTFUNCTION);
                                                     boolean jjtc000 = true;
                                                     jjtree.openNodeScope(jjtn000);SimpleNode n;
    try {
      jj_consume_token(OPENBRACKET);
      n = ExpressionList();
      jj_consume_token(CLOSEBRACKET);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        if (n.jjtGetNumChildren() != params)
                                {if (true) throw new ParseException("Wrong number of parameters for " + name + "!");}
                        jjtn000.setName(name);
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

  final public void Constant() throws ParseException {
         /*@bgen(jjtree) Constant */
                ObjectDBClauseNodeConstant jjtn000 = new ObjectDBClauseNodeConstant(JJTCONSTANT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);Token value;
                int hint;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXTVALUE:
        value = jj_consume_token(TEXTVALUE);
                                hint = HINT_STRING;
        break;
      case FLOATVALUE:
        value = jj_consume_token(FLOATVALUE);
                                hint = HINT_FLOAT;
        break;
      case INTVALUE:
        value = jj_consume_token(INTVALUE);
                                hint = HINT_INTEGER;
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        jjtn000.setName(value.image);
                        jjtn000.setHint(hint);
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

  final public void Field(int hint) throws ParseException {
         /*@bgen(jjtree) Field */
                ObjectDBClauseNodeField jjtn000 = new ObjectDBClauseNodeField(JJTFIELD);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);Token name;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDNAME:
        name = jj_consume_token(IDNAME);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        jjtn000.setName(name.image);
                        jjtn000.setHint(HINT_ID);
        break;
      case FIELDNAME:
        name = jj_consume_token(FIELDNAME);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        jjtn000.setName(name.image);
                        jjtn000.setHint(hint);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

  final public String ClassName() throws ParseException {
                Token cls, name = null;
    cls = jj_consume_token(FIELDNAME);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_AS:
    case FIELDNAME:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_AS:
        jj_consume_token(K_AS);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      name = jj_consume_token(FIELDNAME);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
                        if (name == null)
                                name = cls;

                        if (classMap.get(name.image.toLowerCase()) == null)
                        {
                                classMap.put(name.image.toLowerCase(), classList.size());
                                classList.add(cls.image);
                        }

                        {if (true) return cls.image;}
    throw new Error("Missing return statement in function");
  }

  final public List ClassList() throws ParseException {
                List list = new ArrayList();
                String string;
    string = ClassName();
                  list.add(string);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      string = ClassName();
                          list.add(string);
    }
                  {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode ExpressionList() throws ParseException {
         /*@bgen(jjtree) ExpressionList */
  ObjectDBClauseNodeExpressionList jjtn000 = new ObjectDBClauseNodeExpressionList(JJTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExpressionRoot();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        ExpressionRoot();
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtn000.setName(""); {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  final public void FieldSet() throws ParseException {
         /*@bgen(jjtree) FieldSet */
                ObjectDBClauseNodeFieldSet jjtn000 = new ObjectDBClauseNodeFieldSet(JJTFIELDSET);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);List list = new ArrayList();
                String expr;
                Token fieldName;
    try {
      fieldName = jj_consume_token(FIELDNAME);
                  jjtn000.setName(fieldName.image);
      jj_consume_token(K_EQUAL);
      ExpressionRoot();
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

  final public SimpleNode FieldSetList() throws ParseException {
         /*@bgen(jjtree) FieldSetList */
                ObjectDBClauseNodeFieldSetList jjtn000 = new ObjectDBClauseNodeFieldSetList(JJTFIELDSETLIST);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);List list = new ArrayList();
                String string;
    try {
      FieldSet();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_8;
        }
        jj_consume_token(COMMA);
        FieldSet();
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  final public String ParseSort() throws ParseException {
                Token t;
                String order = "ASC";
                boolean isInt = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ASC:
    case K_DESC:
    case K_INTEGER:
    case FIELDNAME:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ASC:
      case K_DESC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ASC:
          jj_consume_token(K_ASC);

          break;
        case K_DESC:
          jj_consume_token(K_DESC);
                                           order = "DESC";
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_INTEGER:
        jj_consume_token(K_INTEGER);
                                              isInt = true;
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      t = jj_consume_token(FIELDNAME);
                                String suffix = isInt ? ".FieldBigInt" : ".FieldString";
                                {if (true) return "ORDER BY " + getFieldName(t.image) + suffix + " " + order;}
      break;
    case K_RANDOM:
      jj_consume_token(K_RANDOM);
                                {if (true) return "ORDER BY RAND()";}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String ParseLimit() throws ParseException {
                Token t1, t2;
    jj_consume_token(OPENBRACKET);
    t1 = jj_consume_token(INTVALUE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      t2 = jj_consume_token(INTVALUE);
      jj_consume_token(CLOSEBRACKET);
                                {if (true) return "LIMIT " + t1.image + ", " + t2.image;}
      break;
    case CLOSEBRACKET:
      jj_consume_token(CLOSEBRACKET);
                                {if (true) return "LIMIT " + t1.image;}
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public ObjectDbClauseParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[31];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x4000,0x0,0xf0000,0x1f00,0x1f00,0x100,0x8000,0x1000,0x100,0x1000000,0x800000,0xc0500000,0x0,0x0,0x0,0x0,0x0,0x0,0xc0100000,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x6000000,0x6000000,0x8000000,0x1e000000,0x200000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fe003,0xfc,0xfc,0x300,0x300,0xc00,0xc00,0x3fe003,0x380000,0x60000,0x0,0x40000,0x1000,0x1000,0x1000,0x0,0x0,0x0,0x40000,0x1000,};
   }

  public ObjectDbClauseParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ObjectDbClauseParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public ObjectDbClauseParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ObjectDbClauseParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public ObjectDbClauseParser(ObjectDbClauseParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public void ReInit(ObjectDbClauseParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[54];
    for (int i = 0; i < 54; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 31; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 54; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

        }
